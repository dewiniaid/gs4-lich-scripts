=begin
  jarserve2 - Jar inventory management and API.

  THIS SCRIPT IS UNSUPPORTED, and is not polished for a release.  It's uploaded only for the convenience of those
  that I mention it to.

  ;jarserve2 to start it and scan your inventory, then:

  ;vars set jarsack=cloak
  ;vars set jarsack2=backpack
  ....

  ;js2 jar container <container>  - jar all gems in the container
  ;js2 jar right/left/item <itemname> - jar individual gems
  ;js2 query - query all gem statistics
  ;js2 query unc dia - query statistics for gems matching the pattern
  ;js2 bundle - Combine jars of the same gem into less jars.
  ;js2 drop emerald - Drops all emeralds
  ;js2 drop 5 emerald - Drops 5 emeralds
  ;js2 give Luxelle 5 emerald - Gives Luxelle 5 emeralds.  (Unless she declines or the offer times out)
  ;js2 give Luxelle emerald - Gives Luxelle emeralds until she declines or supplies are exhausted
  ;js2 dropjar/givejar - like the above, but entire jars worth of gems

  version: 0.2.3 (2019-06-12)
  author: LostRanger (thisgenericname@gmail.com)
  game: GS
  tags: utility
  required: Lich >= 4.6.0.
=end

=begin


# Shake
You give your <a exist="62298027" noun="jar">jar</a> a hard shake, causing <a exist="62416884" noun="coral">some polished red coral</a> to fall into your left hand.

# Shake empty
You shake your <a exist="62298050" noun="jar">jar</a> a few times before you realize that it is empty.

# Shake now empty
That was the last <a exist="62422737" noun="amethyst">amethyst</a> in the <a exist="62297972" noun="jar">jar</a>.

# Start new jar.  Not a full item name!
You put your <a exist="62425706" noun="amethyst">smoky amethyst</a> into your empty <a exist="62297972" noun="jar">jar</a>.

# Partial? empty.  Requires rescan of both jars.  Has full gem name.
You empty some star sapphires into your <a exist="62298030" noun="jar">glass jar</a>, filling it.

# Full empty. May require rescan
You empty all of the light pink morganite stones into your <a exist="62298038" noun="jar">glass jar</a>.

=end

# unless $SAFE == 0
#     echo "This script must be trusted to run because it needs access to the 'concurrent-ruby' library."
#     echo "To trust it, type #{$lich_char}trust #{@script.name}"
#
# end
#
#
# # We require Ruby's 'Concurrent' library, so try to install it
# begin
#     require 'concurrent'
# rescue Exception => ex
#     echo ex'
#     echo ex.message
#     echo "Ruby's 'concurrent' gem does not appear to be installed.  Trying to install it."
#     begin
#         require 'rubygems'
#         require 'rubygems/dependency_installer'
#     rescue Exception => ex
#         echo ex.message
#         echo "Failed to load rubygems dependencies."
#         exit
#     end
#
#     begin
#         installer = Gem::DependencyInstaller.new({:user_install => true, :document => nil})
#         echo "Downloaded #{installer.install('concurrent-ruby')}"
#     rescue Exception => ex
#         echo ex.message
#         echo "Failed to download gem from default sources, trying http."
#         begin
#             Gem.sources = ['http://rubygems.org/']
#             installer = Gem::DependencyInstaller.new({:user_install => true, :document => nil})
#             echo installer.inspect
#             echo "Downloaded #{installer.install('concurrent-ruby')}"
#         rescue Exception => ex
#             echo ex.message
#             echo "Failed to download gem from http sources, giving up"
#             exit
#         end
#     end
#
#     Gem.clear_paths
#     require 'concurrent'
# end


script.want_downstream = false
script.want_downstream_xml = true


module Jarserve2
    DEBUG_EVENTS = 0

    class Gem
        CACHE = {}

        PLURAL_RULES = {
            # First matching substitution is applied.
            'shadowglass' => 'shadowglass',
            'ies' => 'y',
            #'lapis lazuli' => 'lapis lazuli',
            #'coral' => 'coral',
            'onyxes' => 'onyx',
            'zes' => 'z',
            'teeth' => 'tooth',
            #'bloom' => 'bloom',
            's' => '',
            'teeth' => 'tooth',
        }
        PLURAL_REGEX = /^(.*?)(#{PLURAL_RULES.keys.map{|x| Regexp::escape(x)}.join('|')})$/

        attr_writer :name, :noun_first, :noun_first_plural
        attr_accessor :plural

        def initialize(name, plural=nil, noun_first=nil, noun_first_plural=nil)
            @name = name
            @plural = plural
            @noun_first = noun_first
            @noun_first_plural = noun_first_plural
        end

        def name(count=1)
            return @name unless @plural and count != 1
            return @plural
        end

        def n(count=1)
            "#{count} #{self.name(count)}"
        end

        def noun_first(count=1)
            return self.noun_first_plural if count != 1
            @noun_first = @name.sub(/^(.+)\s+(.+)$/, "\\2, \\1") unless @noun_first
            return @noun_first
        end

        def noun_first_plural
            return @noun_first_plural if @noun_first_plural
            return self.noun_first unless @plural
            @noun_first_plural = @plural.sub(/^(.+)\s+((?<!lapis ).+)$/, "\\2, \\1")
            return @noun_first_plural
        end

        def Gem.one(name)
            return nil unless name
            name = Gem.normalize(name)
            raise 'Ended up with empty-length gem name' if name == ''
            CACHE[name] = Gem.new(name) unless CACHE[name]
            return CACHE[name]
        end

        def Gem.many(plural)
            return nil unless plural
            plural = Gem.normalize(plural)
            name = Gem.singular(plural, true)
            result = Gem.one(name)
            result.plural = plural
            return result
        end

        def Gem.singular(plural, skip_normalize=false)
            plural = Gem.normalize(plural) unless skip_normalize
            if plural =~ PLURAL_REGEX
                return "#{$1}#{PLURAL_RULES[$2]}"
            else
                return plural
            end
        end

        def Gem.normalize(s)
            s = s.full_name if s.is_a?(GameObj)
            s = s.downcase
            return $1 if s =~ /\b(polished (?:ivory|ivories))$/  # I hate ivory
            unless s =~ /^\s*(?:(?:some|a|an|the) )?(?:(?:(?:piece|shard|slice|ribbon|essence)s? of|polished) )?(?:(?:tiny|small|medium|large) )?(.*?)\s*$/
                raise 'FIXME: normalize pattern did not match but should match anything'
            end
            return $1
        end

        def to_s
            return @name
        end

        def <=>(other)
            return self.noun_first_plural <=> other.noun_first_plural
        end
    end


    class JarSet < Set
        attr_reader :gem

        FULL_PROC = proc {|item| item.full?}

        def initialize(gem, snapshot_of=nil)
            if snapshot_of
                super(snapshot_of.map{|jar| jar.snapshot})
                @num = self.num
                @is_snapshot = true
            else
                super()
                @is_snapshot = false
            end
            @gem = gem
        end

        def snapshot
            return @is_snapshot ? self : JarSet.new(@gem, self)
        end

        def num
            return @num if @is_snapshot
            ct = 0
            self.each{|jar|
                return nil unless jar.count
                ct += jar.count
            }
            return ct
        end

        def filled
            self.count(&FULL_PROC)
        end

        def full
            self.select(&FULL_PROC)
        end

        def nonfull
            self.reject(&FULL_PROC)
        end

        def sort(descending: false, include_full: true, &block)
            what = include_full ? self.to_a : self.nonfull.to_a
            if descending
                if block_given?
                    return what.sort{|a,b| -yield(a,b)}
                else
                    return what.sort{|a,b| b<=>a}
                end
            elsif block_given?
                return what.sort(&block)
            else
                return what.sort
            end
        end

        def least_filled(include_full=true)
            # Returns a list of jars sorted by least filled.  Full jars, regardless of capacity, will be last
            # (include_full ? self.to : self.nonfull).sort
            return sort(include_full: include_full)
        end

        def most_filled(include_full=true)
            # Returns a list of jars sorted by most filled.  Full jars, regardless of capacity, will be first
            # (include_full ? self.to : self.nonfull).sort{|a,b| b<=>a}
            return sort(descending: true, include_full: include_full)
        end

        def filter(
            descending: false,
            full: nil,     # 0/false: No full jars.  >0: Take up to this many full jars.  <0: Take all but this many full jars.
            nonfull: nil,  # 0/false: No nonfull jars.  >0: Take up to this many nonfull jars.  <0: Take all but this many nonfull jars.
            skip: 0,       # Omit this many jars from the beginning.  Counts towards full/nonfull jars not taken.
            take: nil,     # Take no more than this many jars.  nil=no limit
            leave: 0      # Omit this many jars from the end.  Counts towards full/nonfull jars not taken.
        )
            len = self.length
            take = len unless take
            full = len unless full
            nonfull = len unless nonfull
            result = JarSet.new(@gem)
            return result if (take <= 0)
            return result if len <= skip+leave
            return result if (full == 0 or -full >= len) and (nonfull == 0 or -nonfull >= len)
            jars = self.sort(descending: descending)
            return self if skip == 0 and leave == 0 and take >= len and full >= len and nonfull >= len
            #echo "Gem=#{self.gem.to_s}.  skip=#{skip} take=#{take} leave=#{leave}.  Jars=#{jars.map{|x| x.full? ? '!' : '.'}.join('')}"

            # skip, leave = leave, skip if descending  # So we can always assume full jars will be last.

            # How many full/nonfull jars in the result?
            numfull = jars.count(&FULL_PROC)
            numnonfull = jars.length - numfull

            calc = proc {|base, query, count|
                next([base, [-query, count].min].max) if query < 0
                [base, count - query].max
            }

            skip, leave = leave, skip if descending
            skip = calc.call(skip, nonfull, numnonfull)
            leave = calc.call(leave, full, numfull)
            skip, leave = leave, skip if descending
            leave = [leave, len - skip - take].max
            return result if skip+leave >= len

            #echo "Gem=#{@gem.to_s}.  skip=#{skip} take=#{take} leave=#{leave}.  Jars=#{jars.map{|x| x.full? ? '!' : '.'}.join('')}"

            if skip > 0 or leave > 0
                skip, leave = leave, skip if descending
                leave = [leave, len - skip - take].max
                jars = jars[skip .. -(leave+1)]
            else
                return self
            end
            jars.each{|jar| result << jar}
            return result
        end

        def filter?(**filters)
            return self unless filters.length > 0
            return self.filter(**filters)
        end
    end

    class ReadOnlyJar
        attr_reader :gem, :id, :status, :count, :container
        def initialize(id, gem, container, count=nil, status=nil)
            @gem = gem
            @id = id
            @container = container
            if @gem
                @count = count
                @status = status
            else
                @count = 0
                @status = 'empty'
            end
        end

        def snapshot
            self
        end

        def retrieve
            fput "get ##{@id}"
        end

        def store
            fput "put ##{@id} in ##{@container}"
        end

        def fast_retrieve
            put "get ##{@id}"
        end

        def fast_store
            put "put ##{@id} in ##{@container}"
        end

        def held?
            (GameObj.right_hand.id == @id or GameObj.left_hand.id == @id)
        end

        def ref
            "##{@id}"
        end

        def refresh
            fput "look in #{self.ref}"
        end

        def empty?
            @count == 0
        end

        def full?
            @status.nil? ? nil : (@status == 'full')
        end

        def <=>(other)
            if other.gem != self.gem
                return 1 unless other.gem
                return -1 unless self.gem
                return other.gem<=>self.gem
            end
            if (self.full? || false) != (other.full? || false)
                return self.full? ? 1 : -1
            end
            return (self.count || -1) <=> (other.count || -1)
        end
    end


    class Jar < ReadOnlyJar
        attr_reader :parent, :container
        def initialize(id, gem, container, count=nil, status=nil)
            super(id, gem, container, count, status)
            @parent = nil
            @snapshot = nil
            # @gem = gem
            # @id = id
            # @container = container
            # if @gem
            #     @count = count
            #     @status = status
            # else
            #     @count = 0
            #     @status = 'empty'
            # end
        end

        def snapshot
            unless @snapshot
                @snapshot = ReadOnlyJar.new(@id, @gem, @container, @count, @status)
            end
            @snapshot
        end

        def container=(newcontainer)
            @snapshot = nil
            @container = newcontainer
        end

        def status=(newstatus)
            return if @status == newstatus
            if @newstatus == 'empty'
                self.gem = nil
            elsif @count == 0 or @gem == nil
                raise "Cannot set the status of a jar to anything other than empty unless it has a gem and a nonzero count."
            end
            @snapshot = nil
            @status = newstatus
        end

        def count=(newcount)
            raise "Count cannot be negative!" if newcount < 0
            return if newcount == @count
            if newcount == 0
                self.gem = nil
            elsif @gem == nil
                raise "Cannot set the count of a jar to anything other than zero when it has no gem."
            else
                @count = newcount
                @status = nil
                @snapshot = nil
            end
        end

        def gem=(newgem)
            return if newgem == @gem
            @snapshot = nil
            if newgem
                @count = nil
                @status = nil
            else
                @count = 0
                @status = 'empty'
            end
            @parent.move(self, newgem)  # noop if parent is nil
            @gem = newgem
        end

        def added_to(what)
            raise "Jar #{self} already has a parent!" if @parent
            @parent = what
        end

        def removed_from(what)
            unless @parent == what
                raise "Jar #{self} does not belong to what it's being removed from!" if @parent
                @parent = what
            end
            @parent = nil
        end

        def store
            if @parent
                @parent.stash(self)
            else
                fput "put ##{@id} in ##{@container}"
            end
        end

        def fast_store
            if @parent
                @parent.stash(self)
            else
                put "put ##{@id} in ##{@container}"
            end
        end

        def empty?
            @count == 0
        end

        def full?
            @status.nil? ? nil : (@status == 'full')
            return @status == 'full'
        end

        def Jar.from_item(item, container)
            item.after_name =~ PATTERNS[:jarcontaining]
            gem = Gem.many($1)
            return Jar.new(item.id, gem, container)
        end

        def <=>(other)
            if other.gem != self.gem
                return 1 unless other.gem
                return -1 unless self.gem
                return other.gem<=>self.gem
            end
            if (self.full? || false) != (other.full? || false)
                return self.full? ? 1 : -1
            end
            return (self.count || -1) <=> (other.count || -1)
        end
    end

    class FutureTimedOut < Exception
        def initialize(future, msg)
            super(msg)
            @future = future
        end
    end

    class FutureFinished < Exception
        def initialize(future, msg = 'Future completed.')
            super(msg)
            @future = future
        end
    end

    class Future
        def initialize
            @waiting = Set.new   # Threads currently blocked waiting for a result.
            @lock = Mutex.new    # Concurrent modification prevention
            @done = false
            @error = nil
            @value = nil
        end

        def value=(new_value)
            @lock.synchronize {
                raise "Cannot assign a value to a completed Future." if @done
                @value = new_value
                make_done
            }
            @when_done.call(self)
        end

        def error=(new_error)
            @lock.synchronize {
                echo new_error.inspect
                echo new_error.backtrace.join("\n")
                raise "Cannot assign an exception to a completed Future." if @done
                @error = new_error
                make_done
            }
            @when_done.call(self)
        end

        def wait_result
            begin
                Thread.handle_interrupt(FutureFinished => :immediate) {
                    @lock.synchronize {
                        return if @done
                        @waiting << Thread.current
                    }
                    sleep
                    raise FutureTimedOut.new(self, "Operation timed out")
                }
            rescue FutureFinished
                return
            end
            # Shouldn't be reachable
            raise 'Thread awoke unexpectedly -- reached unreachable code in fetch_result.  FIXME.'
        end
        private(:wait_result)

        def value
            wait_result
            raise @error if @error
            return @value
        end

        def error
            wait_result
            return @error
        end

        def make_done()
            # Must already be locked!
            @done = true
            @waiting.each {|thr| thr.raise(FutureFinished.new(self, 'Future completed.')) }
            @waiting.clear
        end
        private(:make_done)

        def then(&block)
            @lock.synchronize {
                @when_done = block
                @when_done.call(self) if @done
            }
            @when_done = block
        end

        def execute(&block)
            @lock.synchronize {
                raise "Cannot execute a block on a completed Future." if @done

                begin
                    @value = block.call
                rescue => ex
                    @error = ex
                end
                make_done
            }
            @when_done.call(self)
        end
    end



    attr_accessor :inventory

    TYPEAHEAD = 3  # Only used for the cataloging phase

    PATTERNS = {
        # Matches the result of INV HANDS and GLANCE
        :hands => /(?x)
            ^          # Anchor to start
            (?:<.*\/>)?  # Discard leading XML, if any
            (?:
            (?:You\ glance\ down\ to\ see|You\ have)\    # GLANCE or INV HANDS
            (?:    # Right hand
                (?:nothing|
                (?:(?<right_pre>[^<]+)\ )?
                <a\ exist="(?<right_exist>-?\d+)"\ noun="(?<right_noun>[^"]+)">(?<right_name>[^<]+)<\/a>
                (?:\ (?<right_post>.+?))?)
                \ in\ your\ right\ hand
                (?:\ and \ )?
            )
            (?:    # Left hand
                (?:nothing|
                (?:(?<left_pre>[^<]+)\ )?
                <a\ exist="(?<left_exist>-?\d+)"\ noun="(?<left_noun>[^"]+)">(?<left_name>[^<]+)<\/a>
                (?:\ (?<left_post>.+?))?)
                \ in\ your\ left\ hand
                (?:\ and \ )?
            )
            |You\ glance\ down\ at\ your\ empty\ hands
            |You\ have\ nothing\ in\ your\ hands
            )
            \.\s*
            $
        /,

        # Matches a fully qualified item identifier.
        :itemref => /(?x)
            ^
            (?:<.*>)?  # Discard leading XML, if any
            (?:
               You\ accept\ <a\ exist="(?<from_player_id>-?\d+")\ noun="(?<from_player>[^"]+)">.*<\/a>\ offer\ and\ are\ now\ holding
             | <a\ exist="(?<to_player_id>-?\d+")\ noun="(?<to_player>[^"]+)">.*<\/a>\ has\ accepted\ your\ offer\ and\ is\ now\ holding
             | You\ (?<verb>pick\ up|drop|place|carefully place|put|remove)
            )
            \ (?:(?<pre>[^<]+)\ )?
            <a\ exist="(?<exist>-?\d+)"\ noun="(?<noun>[^"]+)">(?<name>[^<]+)<\/a>
            (?:\ (?<post>(?!from)[^<]+?))?
            (?:   # Source container reference
               (?:\ from)?
               \ (?:(?<location>in|on|under|behind)\ )
               (?:(?<container_pre>[^<]+)\ )?
               <a\ exist="(?<container_exist>-?\d+)"\ noun="(?<container_noun>[^"]+)">(?<container_name>[^<]+)<\/a>
               (?:\ (?!that\ is\ on\ the\ ground)(?<container_post>[^<]+?))?
               (?<floor>(?:\ that\ is\ on\ the\ ground|,\ and\ it\ quickly\ disappears))?
            )?
            \.\s*$   # Terminator
        /,

        # <a exist="-11118378" noun="Jhalk">Jhalk</a> has accepted your offer and is now holding an opalescent <a exist="63748264" noun="jar">glass jar</a> containing star rubies.

        # INV FULL-like results
        :invfull_none => /^You are carrying nothing at this time\.\s*$/,
        :invfull_start => /^You are (?:currently wearing and carrying:\s*$)/,
        :invfull => /^(?<depth> +)(?:(?<pre>[^<]+) )?<a exist="(?<exist>-?\d+)" noun="(?<noun>[^"]*)">(?<name>[^<]*)<\/a>(?: (?<post>.+?))?(?: (?<attrs>\(.*\)))? *$/,
        :invfull_end => /^\((?<count>\d+) items? displayed\.\)\s*$/,

        # Jar status XML
        :jarstatus => /(?x)
            ^(?:<.*>)?  # Anchor, and discard leading XML if any
            (?:The|Inside\ the)
            \ <a\ exist="(?<exist>-?\d+)"\ noun="(?<noun>[^"]+)">(?<name>[^<]+)<\/a>
            \ (?:you\ see\ (?<count>\d+)\ portions?\ of\ (?<gem>.*)\.\ \ It\  )?  # Jar contents, if not empty
            is\ (?<fill>.*)
            \.\s*$   # Terminator
        /,

        :jarcontaining => /^containing (.+)/,

        # Shake success
        :shake_success => /^(?:<.*>)?You give your .*?<a exist="(?<id>-?\d+)".*?<\/a> a hard shake, causing .*?<a exist="(?<gem_id>-?\d+)".*?>(?<gem>.*?)<\/a> to fall into your (?<hand>left|right) hand\.\s*$/,

        # Shake fail
        :shake_was_empty => /^(?:<.*>)?You shake your .*?<a exist="(?<id>-?\d+)".*?<\/a> a few times before you realize that it is empty\./,

        # Jar now empty
        :shake_now_empty => /^(?:<.*>)?That was the last <a.*> in the <a exist="(?<id>-?\d+)".*?<\/a>\./,

        # Generic shake
        :shake => /(?x)
            ^(?:<.*>)?
            You\ (?:give|shake)\ your\ .*?<a\ exist="(?<id>-?\d+)".*?<\/a>
            \ a\ (?:
                few\ times\ before\ you\ realize\ that\ it\ is\ empty
              | (?:
                    hard\ shake,\ causing
                    \ (?:(?<pre>[^<]+)\ )?
                    <a\ exist="(?<exist>-?\d+)"\ noun="(?<noun>[^"]+)">(?<name>[^<]+)<\/a>
                    (?:\ (?<post>[^<]+?))?
                    \ to\ fall\ into\ your\ (?<hand>left|right)\ hand
                )
            )\.\s*$
        /,

        # Empty
        :empty => /^(?:<.*>)?You empty (?<qty>some|all)(?: of the)? (?<gem>.*) into your .*<a exist="(?<id>-?\d+)".*<\/a>(?<full>, filling it)?\./,

        # Empty, empty source
        :empty_empty_source => /^(?:<.*>)?But your <a exist="(?<id>-?\d+)".*?<\/a> is empty!$/,

        # Successful gem store
        :store_success => /(?x)
            ^
            You\ (?<action>add|put)(?:\ your)?
            \ (?:(?<pre>[^<]+)\ )?
            <a\ exist="(?<exist>-?\d+)"\ noun="(?<noun>[^"]+)">(?<name>[^<]+)<\/a>
            (?:\ (?<post>[^<]+?))?
            \ (?:into\ your\ empty|to\ the\ contents\ of\ the)
            \ <a\ exist="(?<jar>-?\d+)\".*<\/a>
            (?<filled>,\ filling\ it)?
            \.\s*$
        /,

        # Failed gem store
        :store_failed => /(?x)
            ^
            The\ <a\ exist="(?<jar>-?\d+)".*?<\/a>
            \ (?:
                (?<full>is\ full!)
                | (?:
                      (?<wrong>
                          already\ contains\ (?<current>[^,]*),
                          \ so\ you\ think\ better\ of\ mixing\ in\ your
                      )
                    | (?<unsuitable>does\ not\ appear\ to\ be\ a\ suitable\ container\ for)
                  )
                  \ (?:(?<pre>[^<]+)\ )?
                  <a\ exist="(?<exist>-?\d+)"\ noun="(?<noun>[^"]+)">(?<name>[^<]+)<\/a>
                  (?:\ (?<post>[^<]+?))?\.
            )\s*$
        /,

        # Giving items to another player
        :offer_started => /^You offer your .* to <a exist="(?<to_player_id>-?\d+)" noun="(?<to_player>[^"]+)">.*, who has 30 seconds to accept the offer/,
        
        :offer_failed => /^(?:You may only have one outstanding offer at a time\.|To whom\?)\s*$/,
    
        :offer_declined => /^<a exist="(?<to_player_id>-?\d+)" noun="(?<to_player>[^"]+)">.+<\/a> has declined the offer.$/,

        :offer_resolved => /(?:^<a exist="(?<to_player_id>-?\d+)" noun="(?<to_player>[^"]+)">.+<\/a> has (?<status>accepted|declined) (?:the|your) offer(?:\.| and is now holding))|(?<expired>Your offer to <a.*<\/a> has expired\.$)/,
    }

    def self.anon_hook(prefix = '')
        now = Time.now
        "Jarserve2::#{prefix}-#{now.tv_sec}.#{now.tv_usec}-#{Random.rand(10000)}"
    end

    def self.cleanup
        [DownstreamHook, UpstreamHook].each{|provider|
            provider.list.find_all{|name| name.start_with?('Jarserve2::')}.each{|name| provider.remove(name)}
        }
    end

    def self.waitre(pattern, timeout=nil)
        if timeout
            begin
                Timeout::timeout(timeout) {
                    return self.waitre(pattern)
                }
            rescue Timeout::Error
                return nil
            end
        end

        xml = nil
        xml = get until xml =~ pattern
        return xml, $~
    end

    def self.quiet_command(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout=5)
        result = []
        name = self.anon_hook
        filter = false

        begin
            Timeout::timeout(timeout, Interrupt) {
                DownstreamHook.add(name, proc {|xml|
                    if filter
                        if xml =~ end_pattern
                            DownstreamHook.remove(name)
                            filter = false
                            # result << xml.rstrip if include_end
                            # thread.raise(Interrupt)
                            # next(include_end ? nil : xml)
                        else
                            # result << xml.rstrip
                            next(nil)
                        end
                    elsif xml =~ start_pattern
                        filter = true
                        # result << xml.rstrip
                        next(nil)
                    else
                        xml
                    end
                })
                fput command

                until (xml = get) =~ start_pattern; end
                result << xml.rstrip
                until (xml = get) =~ end_pattern
                    result << xml.rstrip
                end
                if include_end
                    result << xml.rstrip
                end
            }
        rescue Interrupt
            nil
        end
        return result
    end

    # def self.quiet_command(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout=nil)
    #     hook = self.mask_output(start_pattern, end_pattern, include_end)
    #     fput command
    #     xml, * = waitre(start_pattern, timeout)
    #     unless xml
    #         DownstreamHook.remove(hook)
    #         return nil
    #     end
    #     result = [xml]
    #     return result if xml =~ end_pattern
    #     while true
    #         xml = get
    #         if xml =~ end_pattern
    #             result << xml if include_end
    #             return result
    #         end
    #         result << xml
    #     end
    # end

    def self.mask_output(start_pattern, end_pattern = /<prompt/, include_end = true)
        filter = false
        name = self.anon_hook
        DownstreamHook.add(name, proc {|xml|
            if filter
                if xml =~ end_pattern
                    DownstreamHook.remove(name)
                    filter = false
                    next(include_end ? nil : xml)
                else
                    next(nil)
                end
            elsif xml =~ start_pattern
                filter = true
                next(nil)
            else
                xml
            end
        })
        return name
    end

    def self.gems
        return @gems
    end

    def self.empty
        return @gems[nil]
    end

    def self.[](k)
        @gems[k] = JarSet.new(k) unless @gems[k]
        return @gems[k]
    end

    def self.[]=(k,v)
        @gems[k] = v
    end

    def self.add(jar)
        raise "Jar #{jar} is already added." if @jars[jar.id]
        @jars[jar.id] = jar
        self[jar.gem].add(jar)
        jar.added_to(self)
        return jar
    end

    def self.remove(jar)
        raise "Jar #{jar} is not part of our set of jars." unless @jars[jar.id]
        @jars.delete(jar.id)
        unless self[jar.gem].delete?(jar)
            raise "Jar #{jar} is not a member of the gemset it should be part of."
        end
        jar.removed_from(self)
        @gems.delete(jar.gem) if @gems[jar.gem].length == 0
        return jar
    end

    def self.move(jar, new_gem)
        raise "Jar #{jar} is not part of our set of jars." unless @jars[jar.id]
        return if new_gem == jar.gem
        unless self[jar.gem].delete?(jar)
            raise "Jar #{jar} is not a member of the gemset it should have been part of."
        end
        unless self[new_gem].add?(jar)
            raise "Jar #{jar} is already a member of the gemset it is being moved to."
        end
    end

    def self.is_jar?(item)
        return true if item.type =~ /(?:^|,)jar(?:$|,)/
        return false
    end

    def self.is_jarable?(item)
        return true if item.type =~ /(?:^|,)(?:gem|reagent)(?:$|,)/
        return false
    end

    def self.refresh(jar)
        return if @refresh_inflight.include?(jar.id) or @refresh_pending.include?(jar.id)
        if @refresh_inflight.length > TYPEAHEAD
            @refresh_pending << jar.id
        else
            @refresh_inflight << jar.id
            silence_me if $SAFE == 0
            put "look in #{jar.ref}"
            silence_me if $SAFE == 0
        end
    end

    def self.update_cache(matchdata, prefix='')
        return nil unless matchdata[:"#{prefix}exist"]
        item = item_from_match(matchdata, prefix)
        @itemcache.delete(item.id)
        @itemcache.each{|k,v|
            break if @itemcache.length < 50
            @itemcache.delete(k)
        }
        @itemcache[item.id] = item
    end

    def self.item_from_match(matchdata, prefix='')
        return GameObj.new(
            matchdata[:"#{prefix}exist"],
            matchdata[:"#{prefix}noun"],
            matchdata[:"#{prefix}name"],
            matchdata[:"#{prefix}pre"],
            matchdata[:"#{prefix}post"]
        )
    end

    def self.resolve_gem(text)
        # Returns candidate for a gem description.  Returns matching gems that we have.
        parts = text.strip.downcase.split(/\s+/).map{|word| Regexp::escape(word)}
        pattern = Regexp::new("^#{parts.join('\\S*\\s+')}\\S*$")
        matches = @gems.keys.find_all{|key| key.name =~ pattern or key.plural =~ pattern}
        return matches if matches.length > 0

        pattern = Regexp::new("\\b#{parts.join('.*\\b')}\\S*$")
        return @gems.keys.find_all{|key| key.name =~ pattern or key.plural =~ pattern}
    end

    def self.ingest(xml)
        if xml =~ PATTERNS[:hands]
            items = [update_cache($~, 'right_'), update_cache($~, 'left_')]

            event = {
                :type => :glance,
                :items => items,
                :jars => items.map{|item| @jars[item.id]},
                :gems => items.map{|item| item and is_jarable?(item) ? Gem.one(item.full_name) : nil},
            }
            return event
        elsif xml =~ PATTERNS[:offer_declined]

        elsif xml =~ PATTERNS[:itemref]
            item = update_cache($~)
            event = {
                :type => :itemupdate,
                :add => false,
                :remove => false,
                :item => item,
                :location => $~[:location],
                :container => $~[:container_exist],
            }

            if $~[:to_player_id]
                event[:player_id] = $~[:to_player_id]
                event[:player_name] = $~[:to_player]
                event[:verb] = :give
                event[:remove] = true
            elsif $~[:from_player_id]
                event[:player_id] = $~[:to_player_id]
                event[:player_name] = $~[:to_player]
                event[:verb] = :accept
                event[:add] = true
            else
                case $~[:verb]
                    when 'pick up'
                        event[:verb] = :get
                        event[:add] = true
                    when 'drop', 'carefully place', 'place'
                        event[:verb] = :drop
                        event[:remove] = true
                    when 'put'
                        event[:verb] = :put
                        event[:remove] = true if $~[:floor] or $~[:container_pre] != 'your'
                    when 'remove'
                        event[:verb] = :get
                        event[:remove] = true if $~[:floor] or $~[:container_pre] != 'your'
                    else
                        event[:verb] = :unknown
                        echo "Unknown verb #{$~[:verb].inspect}"
                end
            end

            if is_jar?(item)
                jar = event[:jar] = @jars[item.id]
                if event[:remove] and jar
                    remove(jar)
                elsif event[:add] and not jar
                    echo "Adding jar?"
                    if item.after_name.length > 0 and item.after_name =~ /^containing (.*)/
                        gem = Gem.many($1)
                        refresh(jar)
                    else
                        gem = nil
                    end
                    jar = event[:jar] = add(Jar.new(item.id, gem, nil))
                    refresh(jar) if gem
                end
            end
            return event
        elsif xml =~ PATTERNS[:jarstatus]
            event = {
                :type => :jarupdate,
                :id => $~[:exist],
                :count => $~[:count].to_i, :status => $~[:fill],
                :empty => $~[:fill] == 'empty', :full => $~[:fill] == 'full',
                :gem => Gem.many($~[:gem])
            }
            @refresh_pending.delete(event[:id])
            @refresh_inflight.delete(event[:id])
            # echo "Pending: #{@refresh_pending.length} -- Inflight: #{@refresh_inflight.length}"
            if @refresh_pending.length > 0 and @refresh_inflight.length < TYPEAHEAD
                idnext = @refresh_pending.first
                @refresh_pending.delete(idnext)
                @refresh_inflight << idnext
                silence_me if $SAFE == 0
                put "look in ##{idnext}"
                silence_me if $SAFE == 0
            end
            jar = event[:jar] = @jars[event[:id]]
            if jar
                jar.gem = event[:gem]  # Nil if empty
                if jar.gem
                    jar.count = event[:count]  # nil becomes 0, which is good
                    jar.status = $~[:fill]
                end
            end
            return event
        elsif xml =~ PATTERNS[:shake]
            event = {
                :type => :shake,
                :id => $~[:id],
                :hand => $~[:hand],
                :empty => (not $~[:hand]),
                :item => update_cache($~),
            }
            jar = event[:jar] = @jars[event[:id]]
            return event unless jar

            # Sanity checking
            if event[:empty]
                unless jar.empty?
                    echo "Jar #{jar} was not expected to be empty, but was."
                end
                jar.count = 0
            else
                if jar.empty?
                    echo "Jar #{jar} was expected to be empty, but was not.  Requesting update."
                    refresh(jar)
                    #fput "look in #{jar.ref}"
                else
                    jar.count -= 1   # No effect if count unknown, empties jar if new count is 0.
                end
            end
            return event
        elsif xml =~ PATTERNS[:shake_now_empty]
            event = {
                :type => :became_empty, :source => :shake,
                :id => $~[:id],
            }
            jar = event[:jar] = @jars[event[:id]]
            if jar
                unless jar.empty?
                    echo "Jar #{jar} was not expected to be empty, but was."
                end
                jar.count = 0
            end
            return event
        elsif xml =~ PATTERNS[:empty]  # Empty gems
            event = {
                :type => :bundle,
                :idto => $~[:id],
                :all => $~[:qty] == 'all',
                :idfrom => nil,
                :full => $~[:full] ? true : false
            }

            if event[:idto] == GameObj.right_hand.id
                event[:idfrom] = GameObj.left_hand.id
            elsif GameObj[:idto] == GameObj.left_hand.id
                event[:idfrom] = GameObj.right_hand.id
            else
                echo "Bundled jar #{jar} is not in either hand?"
            end

            unless event[:idfrom]
                echo "Could not find source jar for bundling"
            end

            jarfrom = event[:jarfrom] = @jars[event[:idfrom]]
            jarto = event[:jarto] = @jars[event[:idto]]
            if jarfrom
                if event[:all]
                    jarto.gem = jarfrom.gem
                    jarto.count += jarfrom.count
                    jarto.status = 'full' if event[:full]
                    jarfrom.count = 0
                else  # No idea how many transferred, but target jar is now full for sure.
                    jarfrom.count = nil
                    jarto.count = nil
                    jarto.status = 'full'
                    refresh(jarfrom)
                    refresh(jarto)
                end
            else
                # Unknown source.  Whelp.
                if jarto
                    echo "Bundling gems from an unknown source.  New count unknown."
                    jarto.status = 'full' if event[:full]
                    refresh(jarto)
                else
                    echo "Bundling gems with unknown jars.  No data to record."
                end
            end
            return event
        elsif xml =~ PATTERNS[:store_success]
            # This works due to lazy evaluation
            event = {
                :type => :store,
                :id => $~[:jar],
                :action => $~[:action],
                :new => $~[:action] == 'put',
                :success => true,
                :error => nil,
                :filled => $~[:filled] ? true : false,
                :exist => $~[:exist],
            }
            jar = event[:jar] = @jars[event[:id]]
            gemname = (@itemcache[event[:exist]] or item_from_match($~))
            gem = event[:gem] = Gem.one(gemname)

            if event[:new]
                put 'glance'
            end

            unless jar
                jar = event[:jar] = self.add(Jar.new(event[:id], gem, nil, count: event[:new] ? 1 : nil))
                if jar.count.nil?
                    refresh(jar)
                end
                return event
            end

            if jar.full?
                echo "Unexpectedly added to an existing jar!"
                jar.count = jar.status = nil
                refresh(jar)
                return event
            elsif event[:new]
                if not jar.empty?
                    echo "Unexpectedly started a new jar!"
                end
                jar.gem = gem
                jar.count = 1
                refresh(jar)
                return event
            end

            if jar.gem != gem
                echo "Jar gems mismatched.  #{jar.gem} != #{gem}"
                jar.count = nil
                refresh(jar)
                put 'glance'
                return event
            end

            jar.count += 1 if jar.count
            jar.status = 'full' if event[:filled]
            return event
        elsif xml =~ PATTERNS[:store_failed]
            event = {
                :type => :store,
                :id => $~[:jar],
                :action => nil,
                :new => nil,
                :success => false,
                :exist => $~[:exist],
            }

            jar = event[:jar] = @jars[event[:id]]
            gemname = $~[:exist] ? (@itemcache[event[:exist]] or item_from_match($~)) : nil
            gem = event[:gem] = Gem.one(gemname)

            if $~[:full]
                event[:error] = :full
            elsif $~[:wrong]
                event[:error] = :mismatch
                event[:expected] = $~[:current]
                if jar and jar.gem =~ Gem.many($~[:current])
                    echo "Jar did not match expected contents!"
                    refresh(jar)
                end
            elsif $~[:unsuitable]
                event[:error] = :unsuitable
            else
                event[:error] = :unknown
            end

            return event
        else
            nil
        end
    end

    def self.print_exc(exc)
        respond "#{exc}\n#{exc.backtrace.join("\n")}"
    end

    def self.wait_until_ready
        @ready_future.value
    end

    def self.run(script)
        @script = script
        @itemcache = {}

        @refresh_pending = Set.new
        @refresh_inflight = Set.new

        @jars = {}
        # @gems = Hash.new{|unused, gem| JarSet.new(gem) }
        @gems = {nil => JarSet.new(nil)}

        @eventq = Queue.new
        @taskq = Queue.new
        @sacks = find_sacks('jarsack')

        @refreshlock = Mutex.new
        @lock = Mutex.new

        @ready_future = Future.new


        before_dying { cleanup }

        # Create our downstream XML ingest hook.
        DownstreamHook.add(self.anon_hook('ingest'), proc {|xml|
            @eventq << {:type => :xml, :xml => xml.rstrip}
            xml
        })

        # Add our initial refresh task to the queue
        self.do_refresh(true).then {|fut|
            echo "Initial scan completed in #{fut.value} seconds."
            @ready_future.value = true
        }

        # Consruct the regex for the upstream hook
        command_pattern = /^(?:<c>)?#{Regexp::escape($lich_char)}(?:js2|jarserve2)(?:\s+(\S+)((?:\s+\S+=\S*)+)?(?:\s+(.*?))?)?\s*$/

        # Add upstream hook once refresh is complete.
        UpstreamHook.add(self.anon_hook, proc {|xml|
            next(xml) unless xml =~ command_pattern
            self.perform_command($1, $2, $3)
            next(nil)
        })

        # Execute the event queue

        # Look for task events in the eventq and run them.
        # After each task, run tasks from the taskq until it is empty.
        while true
            #event = @eventq.pop
            #echo "runner|eventq|#{event.inspect}" unless event[:type] == :xml or DEBUG_EVENTS == 0
            #next unless event[:type] == :task
            #self.handle_task(event)
            self.handle_task(getevent(:task, requeue_tasks: false))

            begin
                taskk = @taskq.pop(true)
                echo "runner|taskq|#{taskk.inspect}" unless DEBUG_EVENTS == 0
                self.handle_task(taskk)
            rescue
                nil
            end
        end
    end

    def self.dump_future(future)
        future.then{|f|
            if f.error
                echo "#{f.error.inspect}\n#{f.error.backtrace.join("\n")}"
            else
                echo f.value
            end
        }
    end

    def self.echo(*args)
        args.each{|arg| respond "[#{@script.name}: #{arg}]" }
    end

    BOOLEAN_TABLE = {
        'yes' => true, 'y' => true, '1' => true, 'true' => true, 't' => true,
        'no' => false, 'n' => false, '0' => false, 'false' => false, 'f' => false
    }

    def self.perform_command(command, options_string, argline)
        command = command.downcase
        args = argline.split(/\s+/) or []

        jar_opts = {}
        filter_opts = {}
        if options_string
            options_string.strip.downcase.split(/\s+/).each{|s|
                option, value = s.split('=', 2)
                bvalue = BOOLEAN_TABLE[value.downcase]
                ivalue = value =~ /^-?\d+$/ ? value.to_i : nil

                case option
                    when 'maxfill', 'maxfilled'
                        if ivalue.nil?
                            echo "Invalid value for option '#{option}'"
                            return
                        end
                        jar_opts[:maxfilled] = ivalue
                    when 'allocate'
                        if bvalue.nil?
                            echo "Invalid value for option '#{option}'"
                            return
                        end
                        jar_opts[:only_existing] = !bvalue
                    when 'asc', 'ascend', 'ascending'
                        if bvalue.nil?
                            echo "Invalid value for option '#{option}'"
                            return
                        end
                        filter_opts[:descending] = !bvalue
                    when 'desc', 'descend', 'descending'
                        if bvalue.nil?
                            echo "Invalid value for option '#{option}'"
                            return
                        end
                        filter_opts[:descending] = bvalue
                    when 'take', 'skip', 'leave'
                        filter_opts[option.intern] = value.to_i
                    when 'full', 'nonfull'
                        sym = option.intern
                        unless ivalue == 0
                            filter_opts[:full] = 0 unless filter_opts.include?(:full)
                            filter_opts[:nonfull] = 0 unless filter_opts.include?(:nonfull)
                        end
                        if value == 'all'
                            filter_opts[sym] = nil
                        elsif ivalue.nil?
                            echo "Invalid value for option '#{option}'"
                            return
                        else
                            filter_opts[sym] = ivalue
                        end
                    else
                        echo "Unknown option '#{option}'"
                end
            }
        end

        jar_export = proc{|gemstr, after|
            if gemstr == 'all'
                gems = nil
            elsif gemstr.length > 0
                gems = gemstr.split(/\s*[|;,\/]\s*/)
            else
                echo "Need to specify something to dump, or ALL for all"
                return
            end
            Thread.new {
                jars = flatten_query(do_query(gems, empty: false, **filter_opts).value)
                echo jars.inspect
                dump_future(after.call(jars))
            }
        }

        case command
        when 'reset', 'restart', 'reload'
            dump_future(do_reload(argline))
            return
        when 'refresh'
            dump_future(do_refresh(argline.downcase == 'force'))
            return
        when 'jar'
            if args.length == 0
                dump_future(self.do_jar_item(**jar_opts))
                return nil
            end
            maxfilled = nil
            only_existing = false

            case args[0].downcase
                when 'right'
                    dump_future(self.do_jar_item(GameObj.right_hand, **jar_opts))
                    return nil
                when 'left'
                    dump_future(self.do_jar_item(GameObj.left_hand, **jar_opts))
                    return nil
                when 'item'
                    if args.length == 1
                        dump_future(self.do_jar_item, **jar_opts)
                        return
                    end
                    name = args[1..-1].join(' ')
                    fput "get #{name}"
                    waitre(/<right|left|^Get what\?$|You already have that/, 10)
                    dump_future(self.do_jar_item, **jar_opts)
                    return
                when 'container'
                    if args.length == 1
                        echo "What container?"
                        return
                    end
                    name = args[1..-1].join(' ')
                    dump_future(do_jar_container(name, **jar_opts))
                    return
                when 'floor'
                    dump_future(do_jar_floor(**jar_opts))
                else
                    echo "Jar what?"
                    return
            end
        when 'query'
            echo filter_opts.inspect
            if args.length == 0
                fut = do_query(**filter_opts)
            else
                fut = do_query(argline.split(/\s*[|;,\/]\s*/), **filter_opts)
            end

            fut.then{|fut|
                if fut.error
                    echo "#{fut.error.inspect}\n#{fut.error.backtrace.join("\n")}"
                    next
                end

                maxlen = 0
                totaljars = 0
                totalitems = 0
                output = []
                fut.value[:jars].map{|k,jars|
                    name = k.noun_first_plural
                    # (k.plural or k.name)
                    # name = "#{$2}, #{$1}" if name =~ /^(?:(.*)\s+)(\S*)$/
                    # # if $1
                    # #     name = "$2, $1"
                    # # else
                    # #     name = $12
                    # #
                    # # end

                    maxlen = name.length if name.length > maxlen
                    n = jars.num
                    totalitems += n if n
                    n = '???' unless n
                    text = "#{n.to_s.rjust(4)} gem#{n == 1 ? ' ' : 's'}"
                    n = jars.count
                    totaljars += n if n
                    text += " in #{n.to_s.rjust(3)} jar#{n == 1 ? ' ' : 's'}"
                    n = jars.filled
                    text += " (#{n} full)".rjust(9) if n > 0
                    [name, text]
                }.sort.each{|k, v|
                    output << "#{k.ljust(maxlen, ' .')}: #{v}"
                }

                nempty = (fut.value[:empty].length or 0)
                output << "#{totaljars} jar#{'s' unless totaljars == 1} in query.  #{nempty} empty jar#{'s' unless nempty == 1} available.  #{totalitems} items jarred."

                respond output.join("\n")
            }
        when 'bundle'
            if args.length == 0
                dump_future(do_bundle)
            else
                dump_future(do_bundle(argline.split(/\s*[|;,\/]\s*/)))
            end
        when 'drop'
            if argline =~ /^(\d+|all)\s+(.+?)\s*$/
                dump_future(do_drop_items(gem: $2, count: ($1 == 'all') ? nil : $1.to_i))
                return
            end
            echo "Drop how many of what?"
        when 'give'
            if argline =~ /^(\S+)\s+(\d+|all)\s+(.+?)\s*$/
                dump_future(do_give_items($1, gem: $3, count: ($2 == 'all') ? nil : $2.to_i))
                return
            end
            echo "Give whom how many of what?"
        when 'move'
            if argline =~ /^(\d+|all)\s+(.+?)\s+to\s+(.+)$/
                dump_future(do_move_items($3, gem: $2, count: ($1 == 'all') ? nil : $1.to_i))
                return
            end
            echo "Move how many of what to where?"
        when 'sell'
            if argline =~ /^(\d+|all)\s+(.+?)$/
                dump_future(do_sell_items(gem: $2, count: ($1 == 'all') ? nil : $1.to_i))
                return
            end
            echo "Move how many of what to where?"
        when 'dropjar', 'dropjars'
            jar_export.call(argline, proc {|jars| do_drop_items(jars: jars)})
        when 'givejar', 'givejars'
            whom, argline = argline.split(/\s+/, 2)
            jar_export.call(argline, proc {|jars| do_give_items(whom, jars: jars)})
        when 'movejar', 'movejars'
            if argline =~ /^(.+)\s+to\s+(.+)$/
                jar_export.call($1, proc {|jars| do_move_items($2, jars: jars)})
            else
                echo "Move how many of what to where?"
                return
            end
        else
            echo "Unknown command '#{command}'"
        end
        return nil
    end

    def self.handle_task(event)
        begin
            result = event[:block].call(event)
            event[:future].value = result if event[:future]
        rescue Exception => ex
            event[:future].error = ex if event[:future]
        end
    end

    def self.getevent(*types, requeue_tasks: true)
        if types.length > 0
            types = Set.new(types.flatten)
            event = nil
            event = self.getevent(requeue_tasks: requeue_tasks) until types.include?(event[:type])
            return event
        end

        while true
            event = @eventq.pop()
            echo "getevent|eventq|#{event.inspect}" if DEBUG_EVENTS >= ((event[:type] == :xml) ? 3 : 2)

            if event[:type] == :xml
                event = ingest(event[:xml])
                next unless event
                echo "injected|eventq|#{event.inspect}" if DEBUG_EVENTS >= ((event[:type] == :xml) ? 3 : 2)
                return event
            elsif event[:type] == :task and requeue_tasks
                @taskq << event
            end
            return event
        end
    end

    def self.queue_task(**args, &block)
        fut = Future.new
        @eventq << {:type => :task, :block => block, :future => fut, **args}
        return fut
    end

    def self.find_sacks(base = 'jarsack')
        # Adapted from ;loot
        sacks = []
        ix = nil
        while true
            var = "#{base}#{ix}"
            ix = 1 if ix.nil?
            ix += 1
            name = Vars[var].strip
            return sacks unless name.length > 0
            if name =~ /^my\s+(.*)$/i
                name = $1
            end
            pattern = Regexp::escape(name)
            sack = nil
            [ /\b#{pattern}$/i, /\b#{pattern.sub(' ', '.*')}$/i, /\b#{pattern.sub(' ', '.*')}/i ].each{|pattern|
                sack = GameObj.inv.find {|obj| obj.name =~ pattern }
                break if sack
            }
            if sack
                sacks << sack
            else
                echo "warning: failed to find #{var} '#{name}'"
            end
        end
    end

    def self.hands
        if (GameObj.right_hand.id and not @itemcache[GameObj.right_hand.id]) or (GameObj.left_hand.id and not @itemcache[GameObj.left_hand.id])
            fput 'glance'
            getevent(:glance)
        end
        return [
            GameObj.right_hand.id ? (@itemcache[GameObj.right_hand.id] or GameObj.right_hand) : nil,
            GameObj.left_hand.id ? (@itemcache[GameObj.left_hand.id] or GameObj.left_hand) : nil
        ]
    end

    def self.do_reload(delay=0)
        delay = 0 unless delay
        return self.queue_task{
            start_exec_script("Script.kill('jarserve2'); wait_while{Script.running?('jarserve2')}; sleep #{delay}; start_script 'jarserve2'")
        }
    end

    def self.do_refresh(force=false)
        return self.queue_task {
            started = Time.now
            # Refreshes jar inventory.

            @sacks = find_sacks('jarsack')

            hands.each{|item|
                next unless item
                if is_jar?(item)
                    unless stash(item.id)
                        raise 'Failed to store a jar in your hands.  Inventory is not accurate.'
                    end
                end
            }

            # Run inventory command
            data = self.quiet_command(
                'inventory full containers',
                /(?:#{PATTERNS[:invfull_start]})|(?:#{PATTERNS[:invfull_none]})/
                # /(?:#{PATTERNS[:invfull_end]})|(?:#{PATTERNS[:invfull_none]})/
            )

            container = nil
            jars_found = Set.new

            hook = self.anon_hook('refresh')

            begin
                DownstreamHook.add(hook, proc{|line| line unless line =~ PATTERNS[:jarstatus]})

                # Parse results into jars and start queueing refreshes.
                data.each{|xml|
                    next unless xml =~ PATTERNS[:invfull]
                    case $~[:depth].length
                        when 2
                            container = $~[:exist]
                        when 6
                            unless container
                                echo "Cannot handle inventory line #{xml.inspect} because no parent container was found yet."
                                next
                            end
                            item = item_from_match($~, '')
                            next unless is_jar?(item)

                            jars_found << item.id

                            jar = @jars[item.id]
                            if item.after_name =~ PATTERNS[:jarcontaining]
                                gem = Gem.many($1)
                                unless jar
                                    refresh(self.add(Jar.new(item.id, gem, container)))
                                    next
                                end
                            else
                                gem = nil
                                self.add(Jar.new(item.id, nil, container)) unless jar
                            end

                            oldgem = jar.gem
                            jar.gem = gem
                            refresh(jar) if gem and (force or gem != oldgem)
                        else
                            nil # noop
                    end
                }

                @jars.each{|k,v| self.remove(v) unless jars_found.include?(k) }

                getevent(:jarupdate) until @refresh_inflight.empty? and @refresh_pending.empty?
                next(Time.now - started)
            ensure
                DownstreamHook.remove(hook)
            end
        }
    end

    def self.stash(id, container=nil)
        container = id.container if id.is_a?(Jar) and container.nil?
        id = id.id if id.is_a?(GameObj) or id.is_a?(Jar)

        if container and GameObj.inv.find{|x| x.id == container}
            fput "_drag ##{id} ##{container}"
            *, match = waitre(/(?:^Your .* won't fit in .*)|(?:<(left|right)>Empty<)/, 10)
            if match and match[1]  # otherwise timed out
                waitre /^<prompt/
                return container if match[0]
            end
        end

        @sacks.length.times {
            container = @sacks[0].id
            next unless GameObj.inv.find{|x| x.id == container}
            fput "_drag ##{id} ##{container}"
            *, match = waitre(/(?:^Your .* won't fit in .*)|(?:<(left|right)>Empty<)/, 10)
            if match and match[1] # otherwise timed out
                waitre /^<prompt/
                return container if match[0]
            end
            @sacks << @sacks.shift
            # echo lootsacks.map{|x| x.name}.join('; ')
        }
        return nil
    end

    def self.resolve_container(name, location='in')
        # Figures out what container is being referenced, updates its inventory, and returns its ID.
        # Accepts item IDs or names.  If the item is not a container or has no inventory, returns nil instead.

        pattern = /^(?:<.*>)?(?:<container id=['"](\d+)['"] |<container id=['"]stow['"] [^>]* target=['"]#(\d+)['"]|There is nothing (?:in|on|under|behind) there|Looking under the .*, you see nothing)/
        expected_id = nil
        if name.is_a?(GameObj)
            expected_id = name.id
        elsif name =~ /^#?(\d+)$/
            expected_id = $1
        end
        if expected_id
            name = "##{expected_id}"
        end

        fput "look #{location} #{name}"
        while true
            *, match = waitre(pattern, 10)
            return nil unless match
            result = (match[1] or match[2])
            return result unless (expected_id and result != expected_id)
            # return match[2] unless match[2] and expected_id and match[2] != expected_id
        end
    end

    def self.do_bundle(gems=nil)
        return self.queue_task{
            gems = @gems.keys unless gems

            emptyct = (@gems[nil].length or 0)

            gems.each{|gem|
                next unless gem
                next unless @gems[gem]

                jars = @gems[gem].most_filled(false)
                next if jars.length == 1
                echo jars.inspect


                from = to = nil
                jars.each{|jar|
                    jar.retrieve
                    if to
                        from = jar
                    else
                        to = jar
                        next
                    end
                    fput "empty #{from.ref} into #{to.ref}"
                    event = getevent(:bundle)
                    waitrt
                    if event[:full]  # To jar is now empty.
                        stash(to)
                        to = nil
                    end
                    if event[:all]  # From jar is now empty.
                        stash(from)
                        from = nil
                    elsif to.nil?
                        to = from
                        from = nil
                    end
                }
                stash(from) if from
                stash(to) if to
            }
            next (@gems[nil].length or 0) - emptyct
        }
    end


    class JarError < Exception; end
    class NotJarrableError < JarError; end
    class OutOfJarsError < JarError; end
    class MultipleGemsError < JarError
        attr_reader :input, :matches
        def initialize(input, matches, msg="Ambiguous gem result.")
            super(msg)
            @input = input
            @matches = matches
        end
        def to_s
            return "#{super} #{@input.inspect} => #{matches.map{|x| x.plural or x.name}.inspect}"
        end
    end
    class GemNotFoundError < JarError
        attr_reader :input
        def initialize(input, msg="Gem not found.")
            super(msg)
            @input = input
        end
        def to_s
            return "#{super} #{@input.inspect}"
        end
    end

    def self.jar_for(gem, maxfilled: nil, only_existing: false, **unused)
        if @gems[gem] and @gems[gem].length > 0
            jar = @gems[gem].most_filled(false).first
            unless jar
                if maxfilled and maxfilled <= @gems[gem].filled
                    raise OutOfJarsError.new("Specified fill limit of #{maxfilled} reached.")
                end
            end
        end
        unless jar
            if only_existing
                raise OutOfJarsError.new("No existing non-full jars exist for #{gem} and only_existing was specified.")
            end
            jar = self.empty.first
        end
        unless jar
            if @gems[gem]
                raise OutOfJarsError.new("All jars allocated to #{gem} are full, and no empty jars are available.")
            end
            raise OutOfJarsError.new("No jars are allocated to #{gem}, and no empty jars are available.")
        end
        return jar
    end

    def self.do_jar_item(item=nil, **jar_opts)
        # Jar an item
        # item: GameObj or ID of item to jar. Nil defaults to a currently held item.
        # jar_opts: Passed to jar_for
        item = (GameObj.right_hand.id or GameObj.left_hand.id) unless item

        # jar_opts: modifiers to
        id = item.is_a?(GameObj) ? item.id : item
        raise JarError.new("An item must be specified") unless id

        return self.queue_task{
            holding = hands
            holding_gem = holding.find{|x| x.id == id}
            empty_hands = holding.count(nil)
            if empty_hands != (holding_gem ? 1 : 2)
                raise JarError.new("Must have empty hands or be holding just the item to jar.")
            end

            return_command = nil

            # Get the gem if we need it
            unless holding_gem
                fput "get ##{id}"
                while true
                    event = getevent(:itemupdate)
                    next unless event[:item.id] == id and event[:verb] == :get
                    return_command = "put ##{id} #{event[:location]} ##{event[:container]}"
                    break
                end
            end
            item = @itemcache[id]
            name = item.full_name

            # Is it jarrable?
            unless is_jarable?(item)
                fput return_command if return_command
                raise NotJarrableError.new("Item '#{name}' does not appear to be jarrable.")
            end

            # Find the jars
            gem = Gem.one(name)
            jar = self.jar_for(gem, **jar_opts)
            echo "Jar is #{jar.inspect}"

            # Still here.  Get jar, put gem in jar.  Simple, right?
            fput "get #{jar.ref}"
            fput "put ##{id} in #{jar.ref}"
            event = getevent(:store)
            stash(jar)

            next jar.snapshot if event[:success]
            fput return_command if return_command
            case event[:error]
                when :full
                    raise JarError.new("Jar was unexpectedly full.")
                when :mismatch
                    raise JarError.new("Jar did not contain expected ingredients.")
                when :unsuitable
                    raise NotJarrableError.new("'#{name}' does not appear to be jarrable.")
                else
                    raise JarError.new("Unknown error -- #{event.inspect}")
            end
        }
    end

    def self.do_query(gems=nil, empty: nil, **filters)
        # Return information on gems and what gemsets are holding them.
        if empty and gems
            raise JarError("Query criteria should not specify both 'gems' and a truthy value for 'empty'")
        end
        self.queue_task{
            if empty
                next {
                    :notfound => nil,
                    :jars => nil,
                    :empty => self.empty.filter?(**filters).snapshot
                }
            end
            if gems
                gems = [gems].flatten
            else
                gems = @gems.keys
            end

            notfound = Set.new
            stats = {}

            Set.new(gems.map {|item|
                next(item) if item.is_a?(Gem)
                resolved = self.resolve_gem(item)
                notfound << item if resolved.length == 0
                next(resolved)
            }.flatten).each{|gem|
                next unless gem
                jars = @gems[gem]
                if jars.length == 0
                    notfound << gem
                    next
                end
                filtered = @gems[gem].filter?(**filters)
                stats[gem] = filtered.snapshot if filtered.length > 0

            }

            next {
                :notfound => notfound,
                :jars => stats,
                :empty => empty.nil? ? self.empty.filter?(**filters).snapshot : nil
            }
        }
    end

    def self.flatten_query(query)
        result = Set.new
        query[:jars].each_value{|jars| jars.each{|jar| result << jar}} if query[:jars]
        query[:empty].each_value{|jar| result << jar} if query[:empty]
        return result
    end

    def self.do_query_jars(gems=nil, **filters)
        # Return a flattened list of jars matching the specified query.  GemSets are not included.
        return self.queue_task{
            if gems
                gems = [gems].flatten
            else
                gems = @gems.keys
            end

            notfound = Set.new
            stats = {}

            Set.new(gems.map {|item|
                next(item) if item.is_a?(Gem)
                resolved = self.resolve_gem(item)
                notfound << item if resolved.length == 0
                next(resolved)
            }.flatten).each{|gem|
                next unless gem
                jars = @gems[gem]
                if jars.length == 0
                    notfound << gem
                    next
                end
                stats[gem] = @gems[gem].filter?(**filters).snapshot
            }

            next {
                :notfound => notfound,
                :jars => stats,
                :empty => self.empty.snapshot
            }
        }
    end

    def self.do_jar_floor(refresh: true, **jar_opts)
        return self.queue_task{
            raise JarError.new("This operation requires empty hands.") unless hands.count(nil) == 2

            items = GameObj.loot

            next self.do_jar_gems(items, immediate: true, **jar_opts)
        }
    end

    def self.do_jar_container(container=nil, refresh: true, **jar_opts)
        raise JarError.new("This operation requires a container") unless container
        return self.queue_task{
            raise JarError.new("This operation requires empty hands.") unless hands.count(nil) == 2

            items = nil
            if container.is_a?(GameObj) and not refresh
                items = container.contents
                raise JarError.new("Container has no known contents and :norefresh is true") unless items
            else
                id = self.resolve_container(container)
                raise JarError.new("Container was not found or isn't actually a container") unless id
                items = GameObj.containers[id]
            end

            next self.do_jar_gems(items, immediate: true, **jar_opts)
        }
    end

    def self.is_name_filtered?(name, filters)
        return false unless filters
        keep = nil
        filters.each do |allowed, pattern|
            if name =~ pattern
                return !allowed
            end
            keep = !allowed
        end
        return !keep
    end

    def self.do_jar_gems(items, immediate: false, **jar_opts)
        raise JarError.new("This operation requires a list of items") unless items
        fn = proc {
            raise JarError.new("This operation requires empty hands.") unless hands.count(nil) == 2

            if jar_opts[:itemtype]
                typefilter = /(?:^|,)#{Regexp::escape(jar_opts[:itemtype])}(?:$|,)/
                jar_opts.delete(:itemtype)
            elsif jar_opts[:itemtypes]
                typefilter = /(?:^|,)(?:#{jar_opts[:itemtypes].map{|x| Regexp::escape(x)}.join('|')})(?:$|,)/
                jar_opts.delete(:itemtypes)
            else
                typefilter = nil
            end

            jar_opts[:filter] ||= nil

            result = {
                :stored => {},
                :errors => {},
                :unjarrable => Set.new,
                :notgems => Set.new,
                :gems => Hash.new,
                :filtered => Set.new
            }

            items.each{|item|
                if (typefilter and item.type !~ typefilter) or (is_name_filtered?(item.full_name, jar_opts[:filter]))
                    result[:filtered] << item
                    next
                end

                if is_jarable?(item)
                    gem = Gem.one(item)
                    result[:gems][gem] = Set.new unless result[:gems][gem]
                    result[:gems][gem] << item
                else
                    result[:notgems] << item
                end
            }

            return result if result[:gems].length == 0

            jar = nil
            result[:gems].each{|gem, items|
                fail_rest = nil
                items.each{|item|
                    if fail_rest
                        result[:errors][item] = fail_rest
                        next
                    end
                    if jar
                        unless jar.gem == gem and not jar.full?
                            stash(jar)
                            jar = nil
                        end
                    end
                    unless jar
                        begin
                            jar = jar_for(gem, **jar_opts)
                        rescue OutOfJarsError
                            fail_rest = :noroom
                            result[:errors][item] = :noroom
                            next
                        end
                        fput "get #{jar.ref}"
                    end
                    # Still here.  Move gem to jar
                    fput "_drag ##{item.id} #{jar.ref}"
                    e = getevent(:store)

                    if e[:success]
                        result[:stored][item] = jar
                        next
                    end

                    result[:errors][item] = e[:error]
                    result[:unjarrable] << item if e[:error] == :unsuitable
                }
            }
            stash(jar) if jar

            result[:stored] = Hash[result[:stored].map{|k,v| [k, v.snapshot]}]
            next result
        }
        if immediate
            return fn.call
        else
            return self.queue_task(&fn)
        end
    end

    def self.do_give_items(whom, **what)
        raise JarError.new("A recipient must be specified.") unless whom

        return self.queue_task {
            self.xfer_items(**what){|item|
                fput "give ##{item.id} to #{whom}"
                nil until get =~ /(?:#{PATTERNS[:offer_started]})|(?:#{PATTERNS[:offer_failed]})/
                unless $~[:to_player]
                    raise JarError.new('Failed to give item: Unknown player or offer already pending.')
                end

                nil until get =~ PATTERNS[:offer_resolved]
                next($~[:status] && $~[:status] == 'accepted')
            }
        }
    end

    def self.do_drop_items(**what)
        return self.queue_task {
            self.xfer_items(**what){|item| fput "drop ##{item.id}" }
        }
    end

    def self.do_move_items(container, location='in', **what)
        raise JarError.new("A container must be specified.") unless container
        return self.queue_task {
            if container.is_a?(GameObj)
                id = container.id
            else
                id = self.resolve_container(container)
            end
            raise JarError.new("Failed to find specified container") unless id
            next self.xfer_items(**what){|item| fput "put ##{item.id} in ##{id}" }
        }
    end

    def self.do_sell_items(**what)
        return self.queue_task {
            next self.xfer_items(**what){|item| fput "sell ##{item.id}" }
        }
    end

    def self.xfer_items(gem: nil, jars: nil, count: nil, &block)
        if gem.nil? == jars.nil?
            raise JarError.new('Exactly one of `gem` and `jars` must be set.')
        end
        if count and not gem
            raise JarError.new('Count cannot be specified when transferring an item list.')
        end
        return self.xfer_gems(gem, count, &block) if gem
        return self.xfer_jars(jars, &block)
    end


    def self.xfer_gems(gem, count)
        raise JarError.new("A gem must be specified.") unless gem
        raise JarError.new("This operation requires empty hands.") if GameObj.right_hand.id or GameObj.left_hand.id

        unless gem.is_a?(Gem)
            gems = self.resolve_gem(gem)
            raise GemNotFoundError.new(gem) if gems.length == 0
            raise MultipleGemsError.new(gem, gems) if gems.length > 1
            gem = gems[0]
        end

        unless @gems[gem] and  @gems[gem].length > 0
            raise GemNotFoundError.new(event[:gem])
        end

        # We technically want least filled, but we'll do that from taking the last element of this.
        jars = @gems[gem].most_filled(true)

        result = {
            :items => [],
            :status => count ? :incomplete : :ok,
            :gem => gem
        }

        jar = jars.pop
        jar.retrieve

        begin
            while jar and (count.nil? or count > 0)
                if jar.empty? or jar.gem != gem
                    stash(jar)
                    jar = jars.pop
                    jar.retrieve
                    next
                end

                fput "shake #{jar.ref}"
                e = getevent(:shake)
                unless e[:item]
                    echo 'Seems we got a bad shake result with no item.  Trying another jar.'
                    stash(jar)
                    jar = jars.pop
                    jar.retrieve
                    next
                end

                if yield(e[:item])
                    result[:items] << e[:item]
                    count -= 1 if count
                else
                    fput "put ##{e[:item].id} in #{jar.ref}"
                    result[:status] = :aborted
                    break
                end
            end
        ensure
            stash(jar) if jar
        end
        if count == 0
            result[:status] = :ok
        end

        return result
    end

    def self.xfer_jars(jars)
        raise JarError.new("A list of jars must be specified.") unless jars
        return [] unless jars.length > 0
        jar = nil
        moved = []
        jars.each{|jar|
            begin
                jar.retrieve
                if yield(jar)
                    moved << jar
                else
                    break
                end
            rescue => ex
                stash(jar)
                return moved
                raise ex
            end
        }
        return moved
    end
end

$jarserve2 = Jarserve2
Jarserve2::run(script)
