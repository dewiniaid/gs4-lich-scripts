=begin
  Executes a series of commands for each item matching the criteria you specify.

  Some examples:
    ;foreach box in inv; move to locker
    ;foreach box in locker; move to backpack
    ;foreach gem in cloak; get item; appraise item; put item in container
    ;foreach gem in red sack; move to gemcutter; turn gemcutter; move to blue sack
    ;foreach scroll in inv; read item
    ;foreach gem in backpack; get item; prep 704; cast item; put item in container   (Note: won't check mana)
    ;foreach reagent in inv; get item; sell item
    ;foreach gem in backpack; get item; ;my_script item; put item in container
    ;foreach name=*quartz orb in inv; get item; put item in locker

  Basic usage:
    ;foreach [UNIQUE] [FIRST #] [AFTER #] [[ATTRIBUTE]=VALUE] in <CONTAINER>[; command; command; ...]

  Type ;foreach or ;foreach help for more details and information on functionality, or visit:
  https://github.com/dewiniaid/gs4-lich-scripts/blob/master/Foreach.md

  ;foreach is blind to closed containers.

	  author: LostRanger (thisgenericname@gmail.com)
	  game: any
	  tags: utility
	  required: Lich >= 4.6.0.

  version: 0.9.9 (2019-05-24)

  changelog:
    version 0.9.9 (2019-05-24)
      * Add UNMARK shortcut for MARK <item> REMOVE
      * Improved documentation, including updating the online documentation
      * Convenience shortcuts for in-game verbs should now trigger when abbreviated:
        DRop, PLACe, SELl, APpraise, SELl, and REGister.
      * If the first command is `get`, `take`, `register`, `mark` or `unmark`, an implicit "get item" or
        "remove item" will be added beforehand.  This behavior already existed for drop, place, sell and appraise.
      * If the only command is appraise, register, mark, or unmark, items will be RETURNed
        afterwards in addition to the implicit get/remove item at the start.

    version 0.9.3 (2019-05-24)
      * No longer times out if you `;foreach in empty container` and have FLAG SORTEDVIEW ON
      * Improved error messaging when targetting empty, closed or nonexistant containers.
      * Fix ;foreach quick when using multiple patterns (;foreach q=red,blue in ...)
      * `move to locker` automatically opens your locker just like `foreach in locker` does

    version 0.9.2 (2019-05-22)
      * Now correctly works with locker manifests, even if there's nothing on your armor stand.

    version 0.9.1 (2019-05-21)
      * You can now ;foreach quick=phrase in ... or ;foreach q=phrase in ... as an alternate method for matching items
        This is equivalent to ;foreach fullname=*phrase* in ...   (note wildcards!)

        This feature was documented in 0.9, but was not implemented in that release.

    version 0.9 (2019-05-20)
      * You can now further filter displayed items with ';foreach [un]registered ... in ...` and
        `;foreach [un]marked ... in ...``
      * `;foreach in locker` will now open your locker if it is not already, and will close your locker when it exits
        if it originally opened it.
      * `;foreach in locker` in a premium locker will now try to use your locker manifest to avoid needing to scan
        multiple containers.  This adds a substantial startup speed boost.  If this attempt fails, it is still
        improved in that it will no longer examine the curtain, your disk, or any other non-locker containers in the
        room.
      * Added some more pretty formatting to ;foreach help  (Stormfront only)
      * Make a second attempt at improving compatibility with the Profanity FE

    version 0.8 (2019-05-09)
      * `;foreach in locker` should now work for non-premium lockers.
      * Improve compatibility with the Profanity FE
      * Fix an issue which caused Foreach to stall briefly in some cases.
      * No longer prompts to install xmlpatch on first launch
      * Add waitcastrt, waitcastrt? and waitrt? commands
      * Add sleep X command, where X is a duration.
      * Add UNIQUE, FIRST # and AFTER # modifiers.

    For a full changelog, see https://github.com/dewiniaid/gs4-lich-scripts/blob/master/Foreach.md

    version 0.1 (2017-06-18)
      * Initial release
=end

# [JUST UPDATED] ;foreach 0.9, featuring filtering by marked/registered status, faster scans of premium lockers, and automatic locker opening/closing.  ;repo info foreach -- ;repo download foreach -- ;foreach help

module ForeachScript
    VERSION = '0.9.9 (2019-05-24)'
    CONFIG_VERSION = 2
    FILTER_PATTERN = /^(?:(?:(?:(.+)=)?(.+)\s+([io]n)\s+)|([io]n)\s+)(.+)$/
    INV_PATTERN = /(?:(?:Peering into|[IO]n) .* <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>,? you see )|(?:[OI]n the <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>:\s*$)|(There is nothing [io]n the|That is closed.|I could not find what you were referring to\.)/
    HOOK = 'foreach_script_temp_hook'
    HELP_URL = "https://github.com/dewiniaid/gs4-lich-scripts/blob/master/Foreach.md"

    INVFULL_PATTERN = /^( {2,})([^<]*)<a exist="(-?\d+)" noun="([^"]*)">([^<]*)<\/a>(?: ([^(]*)(?:$|(?= \()))?(?: (\(.*\)))?$/
    # Matches: 1 = leading space, 2 = prename, 3 = id, 4 = noun, 5 = name, 6 = postname, 7 = registered/marked attributes
    # You are carrying nothing at this time.  -- no inventory

    CONTAINER_UPDATE_INTERVAL = 10  # How often do we notify how many more containers are being scanned
    ITEM_UPDATE_INTERVAL = 10  # How often do we notify how many more items are being processed?

    COMMAND_PATTERNS = {
        :move => /^(f(?:ast)?)?(?:move|mv)\s+(?:(.+)\s+)?to\s+(.*)$/i,
    }

    LOCKER_PATTERNS = {
        :start => /^(?:(Looking in front of you, you see)|Thinking back, you recall) the contents of your locker/,
        :end => /^Obvious items:|^There are no items in this locker./,
        :container => /^<pushBold\/>[IO]n .* <a .* noun="(.*)">/,
        :item => /^(?:<popBold\/>)? {6}(?! )([^<]*)<a exist="(-?\d+)" noun="([^"]*)">([^<]*)<\/a>(?: ([^(]*)(?:$|(?= \()))?(?: (\(.*\)))?$/,
        :town_locales => /(Landing|Illistim|Vaalor|Mist Harbor|Kharam|Teras|Icemule|Solhaven|River's Rest)/
    }

    PREMIUM_LOCKER_CONTAINERS = ['armor stand', 'weapon rack', 'magical item bin', 'clothing wardrobe', 'deep chest'].to_set

    UNREGISTERED = 1 << 0
    REGISTERED = 1 << 1
    UNMARKED = 1 << 2
    MARKED = 1 << 3

    # class ForeachOptions
    #     @unique = nil
    #     @marked = nil
    #     @registered = nil
    #     @first = nil
    #     @last = nil
    #
    #     attr_accessor :unique, :marked, :registered, :first, :last
    # end
    #
    # @previous = nil unless defined?(@previous)
    @previous_names = nil unless defined?(@previous_names)

    def self.puts(msg)
        _respond msg
    end

    def self.anon_hook(prefix = '')
        now = Time.now
        "Foreach::#{prefix}-#{now.tv_sec}.#{now.tv_usec}-#{Random.rand(10000)}"
    end

    def self.cleanup
        [DownstreamHook, UpstreamHook].each{|provider|
            provider.list.find_all{|name| name.start_with?('Foreach::')}.each{|name| provider.remove(name)}
        }
    end

    def self.send_formatted(msg, mono=true)
        if @stormfront
            msg = REXML::Text.new(msg, respect_whitespace: true).to_s
            msg.gsub!(/\*\*(.*?)\*\*/, '<preset id="whisper">\1</preset>')
            msg = "<output class=\"mono\" />\n#{msg}\n<output class=\"\" />" if mono
            puts msg
        else
            msg.gsub!('**', '')
            respond msg
        end
    end

    def self.first_time_setup(force = false)
        return if GameSettings['version'] == CONFIG_VERSION and not force

        send = "#{$lich_char}send to #{@script.name}"

        option = proc{|what|
            cmd = "#{send} #{what.upcase}"
            if @stormfront
                puts "    <d cmd=\"#{cmd}\">#{cmd}</d>"
            else
                puts "    #{cmd}"
            end
        }

        unless force
            if GameSettings['version'] == 1
                echo "Migrating settings from a previous version of Foreach..."
                if Script.exists?('GameObjAddMore.lic')
                    unless Script.exists?('xmlpatch.lic')
                        echo "You have GameObjAddMore installed, which is deprecated and will be removed soon."
                        echo "The script 'xmlpatch' replaces it.  I'll go install that for you now."

                        Script.run('repository', 'download xmlpatch.lic')
                        Script.run('xmlpatch')
                    end
                    echo "Done!"
                    puts "\nTo see what's new in this verison and view examples on how to use #{$lich_char}foreach, read the following:"
                    respond "    #{HELP_URL}"
                    GameSettings['version'] = CONFIG_VERSION
                    return
                end
            end
        end

        echo "Starting one time setup..."

        msg = ["**Welcome to ForEach version #{VERSION}**"]
        msg << "**#{'-' * (msg[0].length-4)}**"
        msg << "This one-time setup process will help you get started with ForEach and configure it for future use."
        msg << "Once you've answered a few quick questions, you won't see these messages again."
        msg << ''
        if @stormfront
            msg << "Click on your answers to the questions, or type '#{send} <answer>, where <answer> is your answer."
        else
            msg << "Type '#{send} <answer>' to answer these questions, where <answer> is your answer."
        end
        msg << ''
        send_formatted(msg.join("\n"), false)

        while true
            puts "Would you like Lich to check for updates to this script on startup?\n"
            option.call('yes')
            option.call('no')
            response = unique_get.strip.downcase
            if response =~ /^y(?:es)?$/
                Script.run('repository', "set-updatable #{@script.name}.lic")
                Script.run('autostart', "add --global repository download-updates")
                respond "If you change your mind later, enter #{$lich_char}repository unset-updatable #{@script.name}.lic"
                break
            elsif response =~ /^no?$/
                Script.run('repository', "unset-updatable #{@script.name}.lic")
                respond "If you change your mind later, enter #{$lich_char}repository set-updatable #{@script.name}.lic"
                break
            else
                echo 'Please answer YES or NO'
            end
        end
        puts ''
        sleep 1
        gameobjadd = false
        gameobjaddmore = false
        #
        # while true
        #     puts [
        #         "ForEach has the ability to filter items by type using some functionality built-in to Lich.  However,",
        #         " the data included in Lich is a bit outdated so some items may have the wrong type -- or have no type",
        #         " at all.\n",
        #         "\n",
        #         "I've written a script called 'xmlpatch' that is designed to run on startup and update Lich's data",
        #         " about spells and items.  This script exits afterwards and requires no additional resources beyond that",
        #         " point.\n",
        #         "\n",
        #         "'xmlpatch' replaces and supercedes similar scripts like GameObjAdd and GameObjAddMore.\n",
        #         "\n",
        #         "Would you like me to setup xmlpatch for you?\n"
        #     ].join('')
        #     option.call('yes')
        #     option.call('no')
        #     option.call('info')
        #     response = unique_get.strip.downcase
        #     if response =~ /^y(?:es)?$/
        #         Script.run('repository', "download xmlpatch.lic")
        #         Script.run('xmlpatch')
        #         gameobjadd = true
        #
        #         # respond "If you change your mind later, you can remove GameObjAdd from Autostart with: ${lich_char}autostart remove --global GameObjAdd"
        #         break
        #     elsif response =~ /^no?$/
        #         respond "If you change your mind later, enter the following commands:"
        #         respond "#{$lich_char}repository download xmlpatch.lic"
        #         respond "#{$lich_char}xmlpatch"
        #         break
        #     elsif response =~ /^(?:info|help|details)$/
        #         Script.run('repository', 'info xmlpatch.lic')
        #     else
        #         echo 'Please answer YES, NO or INFO'
        #     end
        # end

        sleep 1
        echo "Just a few more things..."
        puts "You may want to check out some of my other scripts.  Here's a list:"
        Script.run('repository', 'list --author=LostRanger')
        puts ''
        puts [
            "If ForEach is a trusted script, it will hide the commands it is sending to scan inventories and thus",
            " reduce a tiny bit of screen spam.  This is entirely optional and doesn't otherwise affect the script at all.",
            "  You can trust the script with\n",
        ].join('')
        respond "    #{$lich_char}trust foreach"
        puts "(LostRanger recommends that you review the code for scripts before trusting them!)"
        puts "\nTo view information and examples on how to use #{$lich_char}foreach, read the following:"
        respond "    #{HELP_URL}"
        puts "\nTo see a short reminder on how to use #{$lich_char}foreach in game, type:"
        respond "    #{$lich_char}#{@script.name} help"
        puts "\nTo run this setup process again at any time, type:"
        respond "    #{$lich_char}#{@script.name} setup"

        if @script.vars[0].strip.length > 0 and not force
           puts "\nTo run the command you were about to run when Foreach launched its first-time setup, type:"
           respond "    #{$lich_char}#{@script.name} #{@script.vars[0]}"
        end
        GameSettings['version'] = CONFIG_VERSION
        exit
    end

    def self.show_help(full)

        # foreach first 5 box in inv?
        # f
        msg = []
        name = "#{$lich_char}#{@script.name}"
        msg << "**This is ForEach version #{VERSION}**"
        msg << "**Usage:**"
        msg << "    #{name} [OPTIONS] [[ATTRIBUTE=]VALUE] in <TARGET>[; command; command; ...]"
        msg << " or #{name} [OPTIONS] [[ATTRIBUTE=]VALUE] in <TARGET>[/ command/ command/ ...]"
        msg << " or #{name} [OPTIONS] [[ATTRIBUTE=]VALUE] in <TARGET>[| command| command| ...]"
        msg << ''
        if full
            msg << "**ATTRIBUTE** can be one of: `noun`, `name`, `fullname`, `quick`, or `type`.  If unspecified, it is type."
            msg << "    These can also be shortned to `n`, `m`, `f`, `q` or `t`."
            msg << "    `quick` is equivalent to `fullname` with automatic wildcards at the ends."
            msg << ''
            msg << "**VALUE** is what the attribute's value must match.  Wildcards (with *) are supported."
            msg << ''
            msg << "**TARGET** can be a name of a container or one of the following:"
            msg << ''
            msg << "    `INV` or `INVENTORY`  - Contents of all containers in your inventory."
            msg << "    `WORN`              - All worn items in your inventory."
            msg << "    `FLOOR`/`GROUND`/`ROOM` - Items in the room.  (Not their contents)"
            msg << "    `LOOT`              - Contents of items in the room.  (e.g. contents of open boxes on the ground)"
            msg << "    `LOCKER`            - Contents of your locker (including premium locker containers)."
            msg << "    `PREVIOUS` or `LAST`  - All items that matched the previous run of Foreach."
            msg << ''
            msg << "Each **command** will be executed on the item in sequence.  Within each command, the following replacements will be be made:"
            msg << "    `ITEM`      - An exact reference to the item, i.e. it's item number."
            msg << "    `NAME`      - The full name of the item.  Not suitable for commands, suitable for speech."
            msg << "    `NOUN`      - The item's noun.  Unreliable for commands, suitable for speech."
            msg << "    `CONTAINER` - An exact reference to the container the item was found in.  Not available if using `FLOOR`/`GROUND`"
            msg << "                If using `PREVIOUS`, this is the container the item WAS in, not its current location."
            msg << ''
            msg << "**OPTIONS** can consist of any of the following:"
            msg << "    `UNIQUE`         - Only examines the first occurrence for any given full item name."
            msg << "    `FIRST n`        - Only examines the first `n` matching items.  (The word '`FIRST`' is optional.)"
            msg << "    `AFTER n`        - will skip the first `n` matching items.  (You can also use `SKIP`)"
            msg << "    `[UN]MARKED`     - Only considers marked or unmarked items.  Only available for targets in your inventory or premium locker."
            msg << "    `[UN]REGISTERED` - Only considers registered or unregistered items.  Only available for targets in your inventory or your premium locker."
            msg << ''
            msg << "If no commands are specified, #{name} will show a list of all matching items instead."
            msg << "This list will show item types, so '#{name} in backpack' can help you determine which item type to use."
            msg << ''
            msg << "If no attribute or value are specified, #{name} examines all items in the relevant locations."
            msg << ''
            msg << "Each command can be a game command, a lich script (invoked as if typing it in the client), or one of the following"
            msg << "convenience commands:"
            msg << ''
            msg << "    `UNMARK [<item>]`                - Equivalent to MARK <item> REMOVE, but works with shortcuts."
            msg << "    `ECHO <message>`                 - Echo a line of text to your client."
            msg << "    `GIVEITEM <player>`              - Give an item to a player and wait for them to accept it."
            msg << "    `[FAST]MOVE [<item>] TO <where>` - Convenience shortcut for 'get item; put item in container.  <where> can also be `GROUND` or `FLOOR`"
            msg << "    `STASH [<item>]`                 - Attempts to move the item to your lootsack(s), trying them in order if they are full."
            msg << "    `PAUSE`                          - Pause the script.  #{name} will resume where it left off when unpaused."
            msg << "    `SLEEP <time>`                   - Pause for <time> seconds.  Decimals, e.g. '0.5', are allowed."
            msg << "    `WAITRT`                         - Wait for roundtime to finish.  Hangs if not in roundtime."
            msg << "    `WAITCASTRT`                     - Wait for cast roundtime to finish.  Hangs if not in roundtime."
            msg << "    `WAITFOR <phrase>`               - Waits to see the specified phrase.  Case insensitive."
            msg << "    `WAITRE <pattern>`               - Waits to see the specified regular expression."
            msg << "    `WAITMANA <#>` or `WAITMP <#>`     - Waits until you have at least this much mana."
            msg << "    `WAITHEALTH <#>` or `WAITHP <#>`   - Waits until you have at least this much mana."
            msg << "    `WAITSPIRIT <#>` or `WAITSP <#>`   - Waits until you have at least this much stamina."
            msg << "    `WAITSTAMINA <#>` or `WAITST <#>`  - Waits until you have at least this much spirit."
            msg << "    `WAITFOR <phrase>`               - Waits to see the specified phrase.  Case insensitive."
            msg << "    `WAITRE <pattern>`               - Waits to see the specified regular expression."
            msg << ''
            msg << "There are some other convenience shortcuts with certain regular game commands, details are in the online documentation."
            msg << "#{name} is blind to closed containers (except lockers, which will be automatically opened and closed afterwards.)"
            msg << ''
            msg << "If #{name} is trusted ('#{$lich_char}trust #{@script.name}'), its initial inventory scan output will be silenced."
            msg << ''
            msg << "Item types are based on Lich's definition of item types, also seen in #{$lich_char}sorter.  The current list is:"
            msg << GameObj.type_data.map{|k,v| k}.sort.join(', ')
        else
            msg << "**ATTRIBUTEs** include `type`(default), `noun`, `name`, `fullname`, `quick`, or shorthand equivalents `t`, `n`, `m`, `f` and `q`"
            msg << "**TARGETs** include any inventory container or `INV`, `WORN`, `ROOM`, `LOOT`, `LOCKER`, and `LAST` (and various synonyms listed in the full help)"
            msg << "**COMMANDs** are any game command, or convenience shortcuts `UNMARK`, `ECHO`, `GIVEITEM`, `STASH`, `FASTMOVE`, `MOVE`, `PAUSE`, `SLEEP`, `WAITRT`, `WAITCASTRT`, `WAITFOR`, `WAITRE`, `WAITMANA`, `WAITHEALTH`, `WAITSPIRIT`, and `WAITSTAMINA`"
            msg << "**OPTIONS** include `FIRST n`, `AFTER n`, `UNIQUE`, `[UN]MARKED` and `[UN]REGISTERED`"
            msg << ''
        end

        if full
            msg << "**To view detailed documentation and examples online, visit:**"
        else
            msg << "**This is the short version of the documentation.  For more, see #{name} help or visit:**"
        end
        msg << "https://github.com/dewiniaid/gs4-lich-scripts/blob/master/Foreach.md"
        msg << ''

        msg = msg.join("\n")

        if @stormfront
            msg = REXML::Text.new(msg, respect_whitespace: true).to_s
            msg.gsub!(/\*\*(.*?)\*\*/, '<preset id="whisper">\1</preset>')
            msg.gsub!(/`(.*?)`/, '<preset id="speech">\1</preset>')
            msg.gsub!("#{name} help", "</preset><d cmd=\"#{name} help\">#{name} help</d><preset id=\"whisper\">")
            puts "<output class=\"mono\" />\n#{msg}\n<output class=\"\" />"
        else
            msg.gsub!('**', '')
            msg.gsub!('`', '')
            respond msg
        end
    end

    def self.quiet_command(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout=5)
        result = []
        name = self.anon_hook
        filter = false

        begin
            Timeout::timeout(timeout, Interrupt) {
                DownstreamHook.add(name, proc {|xml|
                    if filter
                        if xml =~ end_pattern
                            DownstreamHook.remove(name)
                            filter = false
                            # result << xml.rstrip if include_end
                            # thread.raise(Interrupt)
                            # next(include_end ? nil : xml)
                        else
                            # result << xml.rstrip
                            next(nil)
                        end
                    elsif xml =~ start_pattern
                        filter = true
                        # result << xml.rstrip
                        next(nil)
                    else
                        xml
                    end
                })
                fput command

                until (xml = get) =~ start_pattern; end
                result << xml.rstrip
                until (xml = get) =~ end_pattern
                    result << xml.rstrip
                end
                if include_end
                    result << xml.rstrip
                end
            }
        rescue Interrupt
            nil
        end
        return result
    end

    def self.quiet_inv_scan_hook(xml)
        if @in_sorted_view
            @in_sorted_view = false if xml =~ /Total items: \d+$/
            return nil
        end

        return nil if xml =~ /^<prompt|^s*$/
        return xml unless xml =~ INV_PATTERN
        @in_sorted_view = true if $3
        return nil
        #
        # (xml =~ INV_PATTERN or xml =~ /^<prompt/ or xml =~ /^\s*$/) ? nil : xml
    end

    def self.stop_scripts
        ['sorter'].each{|s|
            if Script.running?(s)
                Script.kill(s)
                @stopped_scripts << s
            end
        }
    end

    def self.resume_scripts
        @stopped_scripts.each{|s| Script.start(s) }
        @stopped_scripts = []
    end

    def self.holding?(id)
        id == GameObj.right_hand.id or id == GameObj.left_hand.id
    end

    def self.find_sacks(base = 'lootsack')
        # Adapted from ;loot
        sacks = []
        ix = nil
        while true
            var = "#{base}#{ix}"
            ix = 1 if ix.nil?
            ix += 1
            name = Vars[var].strip
            return sacks unless name.length > 0
            if name =~ /^my\s+(.*)$/i
                name = $1
            end
            pattern = Regexp::escape(name)
            sack = nil
            [ /\b#{pattern}$/i, /\b#{pattern.sub(' ', '.*')}$/i, /\b#{pattern.sub(' ', '.*')}/i ].each{|pattern|
                sack = GameObj.inv.find {|obj| obj.name =~ pattern }
                break if sack
            }
            if sack
                sacks << sack
            else
                echo "warning: failed to find #{var} '#{name}'"
            end
        end
    end

    def self.build_filter(value, attr, target)
        attr = 'type' unless attr
        return proc {|item| true} unless value

        if attr == 'quick' or attr == 'q' then
            pattern = /(?:#{value.split(/\s*,\s*/).map{|x| "(?:#{Regexp::escape(x).gsub('\*', '.*')})"}.join('|')})/
        else
            pattern = /^(?:#{value.split(/\s*,\s*/).map{|x| "(?:#{Regexp::escape(x).gsub('\*', '.*')})"}.join('|')})$/
        end

        case attr
            when 'type', 't'
                unless GameObj.type_data.find{|k, v| k.split(',').find{|t| t =~ pattern}}
                    echo "No item types match the pattern '#{value}'.  Did you perhaps mean '#{$lich_char}#{@script.name} #{value =~ /\s/ ? 'name' : 'noun'}=#{value} in #{target};...'?"
                    echo "Type '#{$lich_char}#{@script.name}' by itself for more options and a list of item types."
                    exit
                end
                return proc {|item| item.type.split(',').find{|t| t =~ pattern}}
            when 'name', 'm'
                return proc {|item| item.name =~ pattern}
            when 'fullname', 'f', 'quick', 'q'
                return proc {|item| item.full_name =~ pattern}
            when 'noun', 'n'
                return proc {|item| item.noun =~ pattern}
            else
                return nil
        end
    end

    def self.wait_block(message, target, valueproc)
        if valueproc.call < target
            echo message
            wait_until { valueproc.call >= target }
        end
    end

    def self.get_locker_containers
        containers = {}
        GameObj.loot.each do |item|
            if PREMIUM_LOCKER_CONTAINERS.include?(item.full_name)
                containers[item.noun] = item
            end
        end
        return containers if containers.length == PREMIUM_LOCKER_CONTAINERS.length
    end

    def self.is_premium_locker?
        looking_for = PREMIUM_LOCKER_CONTAINERS.dup
        GameObj.loot.each{|item|
            if looking_for.delete?(item.full_name)
                if looking_for.empty?
                    return true
                end
            end
        }
        return false
    end

    def self.get_locker_from_manifest(extended_data)
        locker_containers = self.get_locker_containers
        unless locker_containers
            return nil
        end

        unless Room.current and Room.current.id
            echo "Current room is not mapped.  Unable to determine what town this locker is in."
            return nil
        end

        loc = Room.current.location
        unless loc
            echo "Location of this room is not known.  Unable to determine what town this locker is in."
            return nil
        end

        unless loc =~ LOCKER_PATTERNS[:town_locales]
            echo "Location of this room is not familiar.  Unable to determine what town this locker is in."
            return nil
        end

        manifest_command = "locker manifest #{$1}"

        data = quiet_command(manifest_command, LOCKER_PATTERNS[:start])

        to_filter = {}
        container_names = {}
        current_container = nil
        finished = false

        data.each{|xml|
            if xml =~ LOCKER_PATTERNS[:start]
                unless $1   # Remote locker, not local locker
                    echo "Location of this room appears to be incorrect, or your locker is not open."
                    return nil
                end
            elsif xml =~ LOCKER_PATTERNS[:end]
                finished = true
            elsif xml =~ LOCKER_PATTERNS[:container]
                unless (t = locker_containers[$1])
                    echo "Unrecognized container noun: #{$1}"
                    return nil
                end
                current_container = t.id
                container_names[current_container] = t.full_name
                to_filter[current_container] = []
            elsif xml =~ LOCKER_PATTERNS[:item]
                unless current_container
                    echo "I found an item in a container before I found my first container.  This shouldn't happen."
                    echo "Please save a copy of #{manifest_command.upcase} and contact LostRanger"
                    exit
                end

                item = GameObj.new($2.dup, $3.dup, $4.dup, $1.dup, $5.dup)
                to_filter[current_container] << item
                extended_data[item.id] = extended_data_value($6) if extended_data
            end
        }

        unless finished
            echo "Locker manifest read was incomplete"
            return nil
        end

        return {
            :to_filter => to_filter,
            :container_names => container_names,
        }
    end

    def self.extended_data_from_inv(extended_data, command="inv full")
        waitrt?
        return unless extended_data
        data = self.quiet_command(
            command,
            /^(?:You are carrying nothing at this time|You are currently (?:wearing and )?carrying)/,
            /(?:<prompt)|(?:.*items? displayed\.\)$)/,
            # /(?:<prompt)|(?:items displayed.\)\b)/,
            true,
            5
        )
        unless data
            echo "Inventory request timed out."
            exit
        end
        data.each{|xml|
            next unless xml =~ INVFULL_PATTERN
            item = GameObj.new($3.dup, $4.dup, $5.dup, $2.dup, $6.dup)
            extended_data[item.id] = extended_data_value($7)
        }

        return extended_data
    end

    def self.extended_data_value(text)
        value = 0
        return UNREGISTERED | UNMARKED unless text
        if text =~ /registered/i
            value |= REGISTERED
        else
            value |= UNREGISTERED
        end

        if text =~ /marked/i
            value |= MARKED
        else
            value |= UNMARKED
        end
    end

    def self.open_locker
        return if @opened_locker
        @opened_locker = true
        put "open locker"
        while (line = get)
            if line =~ /^Your locker is currently holding/
                before_dying { waitrt?; put "close locker" }
                return
            elsif line =~ /^That is already open|What were you referring to/
                return
            end
        end
    end

    def self.autocompletes_to(input, command)
        prefix, rest = command.split('|')
        command = prefix + rest
        return input.length >= prefix.length && command.start_with?(input)
    end

    def self.run(script)
        @opened_locker = false
        @stormfront = ($frontend == 'stormfront')
        @profanity = ($frontend == 'profanity')
        @script = script
        @script.want_downstream = false
        @script.want_downstream_xml = true

        options = {}
        extended_data = nil

        self.first_time_setup(@script.vars[0] =~ /^\s*setup\s*$/i ? true : false)

        @stopped_scripts = []
        before_dying {
            self.cleanup
            resume_scripts
        }

        @script.vars[0] =~ /^\s*(.+?)\s*(?:([;\/|])\s*(.*?)\s*)?$/
        filter = $1
        separator = $2
        commands = $3

        # Read first/skip/unique bits.
        while filter =~ /^(?:(unique|(?:un)?(?:marked|registered))|(?:(?:(first|after|skip)\s+)?(\d+)))\s+(.*)/i
            filter = $4
            if $1
                if $1 == 'unique'
                    if options[:unique]
                        echo "'unique' specified more than once."
                        exit
                    end
                    options[:unique] = true
                else
                    opt = $1
                    value = !opt.start_with?("un")
                    unless value
                        opt = opt[2, opt.length]
                    end
                    sym = opt.to_sym
                    if options[sym].nil?
                        options[sym] = value
                    elsif options[sym] == value
                        echo "'#{$1}' specified more than once."
                        exit
                    else
                        echo "Cannot specify both '#{opt}' and 'un#{opt}."
                        exit
                    end
                end
            elsif $3
                if not $2 or $2.downcase == 'first'
                    if options[:first]
                        echo "'first' specified more than once."
                        exit
                    end
                    options[:first] = $3.to_i
                else
                    if options[:skip]
                        echo "'skip' specified more than once."
                        exit
                    end
                    options[:skip] = $3.to_i
                end
            end
        end

        options[:skip] ||= 0
        options[:extdata_filter] = 0
        options[:extdata_filter] |= UNMARKED if options[:marked] == false
        options[:extdata_filter] |= MARKED if options[:marked] == true
        options[:extdata_filter] |= UNREGISTERED if options[:registered] == false
        options[:extdata_filter] |= REGISTERED if options[:registered] == true
        extended_data = {} if options[:extdata_filter] != 0

        # Determine filter and container bits.
        unless filter =~ FILTER_PATTERN
            self.show_help((filter =~ /^help$/i) ? true : false)
            exit
        end

        filter_attr = ($1.downcase or 'type')
        filter_value = $2
        position = ($3 or $4)
        target = $5
        explicit_all = false  # Safety bypass.

        if filter_attr == 'type' and filter_value =~ /all|any|everything/i
            explicit_all = true
            filter_attr = nil
            filter_value = nil
        end

        filter_proc = self.build_filter(filter_value, filter_attr, target)
        unless filter_proc
            echo "Unknown attribute '#{filter_attr}'"
            exit
        end

        # Process commands
        lootsacks = nil

        if separator and commands
            commands = commands.split(/\s*#{Regexp::escape(separator)}\s*/)
            count = commands.length
            next_is_script = false
            new_commands = []
            commands.each_with_index{|command, ix|
                if command == ''  # Blank.
                    # Due to the split, a Lich script will appear as a blank command followed by the script invocation
                    # as the next command -- if the separator and $lich_char are the same.  Flag this for the next run
                    next_is_script = ($lich_char == separator)
                    # Continue to the next iteration rather than adding this command, too.
                    count -= 1
                    next
                end
                if next_is_script
                    next_is_script = false
                    # Convert to script invocation
                    command = "#{$lich_char}#{command}"
                else
                    command =~ /^(\w+)(.*)$/
                    # Autocomplete command to simplify coding in other shortcuts
                    first_word = $1.downcase
                    rest = $2
                    if first_word
                        %w(dr|op plac|e sel|l ap|praise reg|ister ge|t tak|e).each{|verb|
                            if self.autocompletes_to(first_word, verb)
                                command = verb.gsub('|', '') + rest
                                break
                            end
                        }
                    end
                end

                if command =~ /^(drop|place|sell|appraise|stash|register|mark|unmark|get|take)$/i
                    # Add implicit ITEM if no modifiers.
                    command = "#{$1} item"
                end
                if command =~ /^stash\s+/i and not lootsacks
                    # Adapted from ;loot, with heavy modifications
                    lootsacks = self.find_sacks('lootsack')
                    unless lootsacks.length > 0  # Already did the search
                        echo "Failed to find any lootsacks, STASH will not work."
                        echo "Configure lootsacks with ;vars set lootsack=container, ;vars set lootsack2=container, etc...."
                        exit
                    end
                end
                if ix == 0  # First command logic.
                    # Add implicit GETs when no modifiers.
                    if command =~ /^drop\s+item$/i
                        command = '_drag item drop'
                    elsif command =~ /^(?:giveitem)|(?:place|sell|(appraise|register|mark|unmark))\s+item$/i
                        implicit_return = $1 && (count == 1)
                        if target =~ /^worn$/i
                            new_commands << 'remove item'
                        else
                            new_commands << 'get item'
                        end
                        new_commands << command
                        new_commands << "return" if implicit_return
                        next
                        #
                        #
                        #
                        # implicit_return = command =~ /^(?:appraise|register|mark|unmark)\s+item/
                        # implicit_get = implicit_return || command =~ /^(giveitem)|^(?:(place|sell|app(?:raise)?)\s+item)$/i
                        # command =~ /^(giveitem)|^(?:(place|sell|app(?:raise)?)\s+item)$/i
                        # implicit_return = count == 1 && !$1
                        # if target =~ /^worn$/i
                        #     new_commands << 'remove item'
                        # else
                        #     new_commands << 'get item'
                        # end
                    end
                end
                new_commands << command
                # if commands.length == 1 and command =~ /^app(?:raise)?\s+item$/i
                #     new_commands << 'return'
                # end
            }
            commands = new_commands
        end

        # Find possible item IDs
        to_scan  = []
        to_filter = {}
        container_names = {nil => 'On the ground'}
        silence_me if $SAFE == 0

        if target =~ /^(?:locker)$/i
            open_locker
        end

        if target =~ /^inv(?:entory)?$/i  # Entire inventory
            # Sanity check
            if commands.length > 0 and filter_value.nil?
                echo 'WARNING: THIS COMMAND WILL ACT ON EVERY ITEM THAT YOU HAVE IN YOUR ENTIRE INVENTORY!'
                if explicit_all
                    echo "'#{$lich_char}kill #{@script.name}' to abort!"
                    sleep 0.5  # A moment before it all scrolls off
                else
                    echo "If you REALLY want to do this, you must explicitly say so by using '#{$lich_char}#{@script.name} ALL in #{target}';..."
                    exit
                end
            end

            # Parse INV FULL output, sort of.
            data = self.quiet_command(
                'inv full',
                /^(?:You are carrying nothing at this time|You are currently wearing and carrying)/,
                /(?:<prompt)|(?:.*items? displayed\.\)$)/,
                # /(?:<prompt)|(?:items displayed.\)\b)/,
                true,
                5
            )
            unless data
                echo "Inventory request timed out."
                exit
            end
            last_container = nil
            last_container_name = nil
            data.each{|xml|
                next unless xml =~ INVFULL_PATTERN
                # echo $~.inspect
                case $1.length
                    when 2
                        last_container = $3
                        last_container_name = $5
                    when 6
                        unless last_container
                            echo "I found an item in a container before I found my first container.  This shouldn't happen."
                            echo "Please save a copy of INV FULL and contact LostRanger"
                            exit
                        end
                        item = GameObj.new($3.dup, $4.dup, $5.dup, $2.dup, $6.dup)
                        unless to_filter[last_container]
                            to_filter[last_container] = []
                            container_names[last_container] = last_container_name
                        end
                        to_filter[last_container] << item

                        # Read extdata if we need it
                        extended_data[item.id] = self.extended_data_value($7) if extended_data
                    else
                        next
                end
            }
        elsif target =~ /^(?:prev(?:ious)?|last)$/i  # Previous run
            unless @previous
                echo "No previous run data is available."
                exit
            end
            if extended_data
                echo "Target 'previous' does not support filtering by mark or registration status."
                exit
            end
            to_filter = @previous
            container_names = @previous_names
        elsif target =~ /^(?:loot)$/i  # Loot in room
            if extended_data
                echo "Target 'loot' does not support filtering by mark or registration status."
                exit
            end
            to_scan = GameObj.loot.map{|item| item.id}
            GameObj.loot.each{|item| container_names[item.id] = item.full_name}
        elsif target =~ /^(?:locker)$/i and self.is_premium_locker?
            manifest = get_locker_from_manifest(extended_data)
            if manifest
                to_filter = manifest[:to_filter]
                container_names = manifest[:container_names]
            else
                if extended_data
                    echo "I had to fall back to legacy locker scanning, which means I can't filter by mark or registration status."
                    echo "Most likely, this can be fixed by updating the MapDB for this locker.  Please contact LostRanger with the room number (if known), description, and location for details."
                    exit
                end

                # Fall back to legacy locker scan.
                locker_containers = GameObj.loot.keep_if{|x| PREMIUM_LOCKER_CONTAINERS.include?(x.full_name)}
                to_scan = locker_containers.map{|item| item.id}
                locker_containers.each{|item| container_names[item.id] = item.full_name}
            end
        elsif target =~ /^(?:floor|ground|room)$/i  # Items on ground
            if extended_data
                echo "Target '#{target}' does not support filtering by mark or registration status."
                exit
            end
            to_filter[nil] = GameObj.loot
        elsif target =~ /^worn$/i  # Worn items
            to_filter[nil] = GameObj.inv
            container_names[nil] = 'On your person'
        else   # A specific container
            if target =~ /^locker$/i
                if extended_data
                    echo "Target 'locker' only supports filtering by mark or registration status when used on a premium locker."
                    exit
                end
                open_locker
            end
            stop_scripts
            xml = dothistimeout("look #{position} #{target}", 15, INV_PATTERN)
            unless xml =~ INV_PATTERN
                echo "Timed out waiting for inventory command."
                exit
            end
            error = $5
            if error
                if error.start_with?("There")  # is nothing in there
                    echo "Target container is empty."
                elsif error.start_with?("That")  # is nothing in there
                    echo "Target container is closed."
                else
                    echo "Target container was not found."
                end
                exit
            end
            exist = ($1 or $3)
            name = ($2 or $4)
            unless exist
                echo "Error locating item or item inventory."
                exit
            end
            unless GameObj.containers[exist]
                echo "Error loading item inventory."
                exit
            end

            to_filter[exist] = GameObj.containers[exist]
            container_names[exist] = name

            if extended_data
                if GameObj.right_hand.id == exist or GameObj.left_hand.id == exist
                    self.extended_data_from_inv(extended_data, 'inv hands full')
                else
                    self.extended_data_from_inv(extended_data)
                    self.extended_data_from_inv(extended_data, 'inv hands full') unless extended_data[exist]
                end
                unless extended_data[exist]
                    echo "The container '#{container_names[exist]}' does not appear to be in your inventory, which means that marked/registered information cannot be obtained from it."
                    exit
                end
            end
        end

        if to_scan.length > 0
            stop_scripts
            remaining = to_scan.length
            echo "Scanning #{remaining} inventor#{remaining==1 ? 'y' : 'ies'}, please wait..."  # if $SAFE == 0
            hook = self.anon_hook
            @in_sorted_view = false
            DownstreamHook.add(hook, proc {|xml| self.quiet_inv_scan_hook(xml)})
            to_scan.each{|exist|
                if remaining != to_scan.length and remaining % CONTAINER_UPDATE_INTERVAL == 0
                    echo "Still scanning #{remaining} inventor#{remaining==1 ? 'y' : 'ies'}, please wait..."  # if $SAFE == 0
                end
                remaining -= 1
                fput "look #{position} ##{exist}" }
            waitfor '<prompt'
            DownstreamHook.remove(hook)

            scanned_inv = scanned_hands = false
            to_scan.each{|exist|
                to_filter[exist] = GameObj.containers[exist]
                if extended_data
                    if GameObj.right_hand.id == exist or GameObj.left_hand.id == exist
                        self.extended_data_from_inv(extended_data, 'inv hands full') unless scanned_hands
                        scanned_hands = true
                    else
                        self.extended_data_from_inv(extended_data) unless scanned_inv
                        scanned_inv = true
                        unless extended_data[exist] or scanned_hands
                            self.extended_data_from_inv(extended_data, 'inv hands full')
                            scanned_hands = true
                        end
                    end
                    unless extended_data[exist]
                        echo "The container '#{container_names[exist]}' does not appear to be in your inventory, which means that marked/registered information cannot be obtained from it."
                        exit
                    end
                end
            }

            self.extended_data_from_inv(extended_data) if extended_data
        end

        resume_scripts
        silence_me if $SAFE == 0

        total_items = 0
        filtered = {}

        first = options[:first]
        skip = options[:skip]
        extdata_filter = options[:extdata_filter]
        unique = options[:unique]
        unique_count = {}

        # echo options.inspect
        # echo extended_data.inspect
        #
        to_filter.each{|container, items|
            unless (items and items.length > 0) and (first.nil? or first > 0)
                container_names.delete(container)
                next
            end

            # Filter out items by registration status
            if extended_data
                items.keep_if{|item|
                    unless extended_data[item.id]
                        echo "Failed to retrieve marked/registered info for '#{item.full_name}'.  Most likely this is because it is in a container not in your inventory."
                        exit
                    end
                    (extended_data[item.id] & extdata_filter) == extdata_filter
                }
            end

            if unique
                items.keep_if{|item| filter_proc.call(item) and unique_count[item.full_name] ||= 0 and (unique_count[item.full_name]+=1)==1}
            else
                items.keep_if{|item| filter_proc.call(item)}
            end

            unless items.length > 0
                container_names.delete(container)
                next
            end

            if skip >= items.length
                skip -= items.length
                container_names.delete(container)
                next
            elsif skip > 0
                items = items.drop(skip)
                skip = 0
            end

            unless first.nil?
                if first >= items.length
                    first -= items.length
                else
                    items = items.first(first)
                    first = 0
                end
            end

            total_items += items.length
            filtered[container] = items
        }

        if total_items == 0
            echo 'No matching items found!'
            exit
        end

        @previous = filtered
        @previous_names = container_names

        before_next = nil  # Possibly skippable things to do before the next command.

        move_container_cache = {}

        processed_items = 0
        filtered.each{|container, items|
            # next unless items.length > 0
            # items = items.find_all{|item| filter.call(item)}
            # next unless items.length > 0
            if commands.length > 0
                items.each{|item|
                    ref = "##{item.id}"
                    if processed_items % ITEM_UPDATE_INTERVAL == 0
                        percent = (100.0 * processed_items / total_items).to_i
                        echo "Item #{processed_items + 1} of #{total_items}.  (#{percent}% complete)"
                    end
                    commands.each_with_index{|original, ix|
                        command = (
                            original
                            .gsub(/\bitem\b/i, ref)
                            .gsub(/\bnoun\b/i, item.noun)
                            .gsub(/\bname\b/i, item.name)
                            .gsub(/\bcontainer\b/i, ("##{container}"))
                        )
                        if command.start_with?($lich_char)
                            before_next.call if before_next
                            before_next = proc { waitrt? }
                            scriptname, args = command.split(/\s+/, 2)
                            scriptname = scriptname[1..-1]
                            echo "Running #{$lich_char}#{scriptname} #{args}"
                            Script.run(scriptname, args)
                        elsif command =~ COMMAND_PATTERNS[:move]
                            before_next.call if before_next
                            before_next = nil
                            fast = $1 ? true : false
                            what = ($2 or ref)
                            where = $3
                            holding = (what == ref and self.holding?(item.id))
                            floor = (where =~ /^(?:ground|floor)$/i) ? true : false
                            if what[0] == '#'
                                if floor
                                    fput "_drag #{what} drop"
                                    waitfor '<right>Empty', '<left>Empty'
                                    next
                                end
                                open_locker if where =~ /^locker$/i  # Convenience
                                where = move_container_cache[where] if move_container_cache[where]
                                if where[0] == '#'
                                    fput "_drag #{what} #{where}"
                                    waitfor '<right>Empty', '<left>Empty'
                                    next
                                end
                            end
                            get_command = "get #{what}"
                            put_command = floor ? "place #{what}" : "put #{what} in #{where}"

                            unless holding
                                if fast
                                    put get_command
                                else
                                    fput get_command
                                end
                            end
                            if fast
                                put put_command
                            else
                                fput put_command
                            end
                            waitfor '<right>', '<left>'
                            next if floor

                            unless where[0] == '#' or move_container_cache.include?(where)
                                nil until get =~ /^(?:(?:<.*>)?You (?:put|absent-mindedly drop) (?:[^<]*)<a exist="(-?\d+).*?<\/a>.*<a exist="(-?\d+).*?<\/a)|<prompt/
                                move_container_cache[where] = ($2 and GameObj.inv.find{|x| x.id == $2}) ? "##{$2}" : false
                                # if $2
                                #     # echo "Learned that '#{where}' is ##{$2}"
                                #     if GameObj.inv.find{|x| x.id == $2}
                                #         # echo "Learned that '##{$2}' is an inventory container, and probably doesn't support ON/UNDER/BEHIND"
                                #         move_container_cache[where] = "##{$2}"
                                #     else
                                #         # echo "Learned that '##{$2}' is NOT an inventory container, and might support ON/UNDER/BEHIND"
                                #         move_container_cache[where] = false
                                #     end
                                # else
                                #     # echo "Learned that '#{where}' is probably a scripted container of some sort."
                                #     move_container_cache[where] = false
                                # end
                                # if $2
                                #     # echo "Learned that '#{where}' is ##{$2}"
                                #     if GameObj.inv.find{|x| x.id == $2}
                                #         # echo "Learned that '##{$2}' is an inventory container, and probably doesn't support ON/UNDER/BEHIND"
                                #         move_container_cache[where] = "##{$2}"
                                #     else
                                #         # echo "Learned that '##{$2}' is NOT an inventory container, and might support ON/UNDER/BEHIND"
                                #         move_container_cache[where] = false
                                #     end
                                # else
                                #     # echo "Learned that '#{where}' is probably a scripted container of some sort."
                                #     move_container_cache[where] = false
                                # end
                            end

                            #
                            #
                            #
                            #
                            #     fput "get #{what}" unless what == ref and self.holding?(item.id)
                            #     waitfor '<right>', '<left>'
                            # end
                            # if where =~ /^(?:ground|floor)$/i
                            #     fput "place #{what}"
                            # else
                            #     fput "put #{what} in #{where}"
                            # end
                            # waitfor '<right>', '<left>'
                        # elsif command =~ /^f(?:ast)?(?:move|mv)\s+(?:(.+)\s+)?to\s+(.*)$/i
                        #     before_next.call if before_next
                        #     before_next = nil
                        #     what = ($1 or ref)
                        #     where = $2
                        #     holding = (what == ref and self.holding?(item.id))
                        #     put "get #{what}" unless holding
                        #     put "put #{what} in #{where}"
                        #     waitfor '<right>', '<left>' unless holding
                        #     waitfor '<right>', '<left>'
                        elsif command =~ /^wait(?:mana|mp) (-?\d+)$/
                            before_next.call if before_next
                            before_next = nil
                            n = $1.to_i
                            self.wait_block("Waiting for #{n} mana...", n, proc { XMLData.mana })
                        elsif command =~ /^wait(?:health|hp) (-?\d+)$/
                            before_next.call if before_next
                            before_next = nil
                            n = $1.to_i
                            self.wait_block("Waiting for #{n} HP...", n, proc { XMLData.health })
                        elsif command =~ /^wait(?:spirit|sp) (-?\d+)$/
                            before_next.call if before_next
                            before_next = nil
                            n = $1.to_i
                            self.wait_block("Waiting for #{n} spirit...", n, proc { XMLData.spirit })
                        elsif command =~ /^wait(?:stamina|st) (-?\d+)$/
                            before_next.call if before_next
                            before_next = nil
                            n = $1.to_i
                            self.wait_block("Waiting for #{n} stamina...", n, proc { XMLData.stamina })
                        elsif command =~ /^stash (.*$)/i
                            before_next.call if before_next
                            before_next = nil
                            what = $1
                            success = false
                            lootsacks.length.times{
                                sack = lootsacks[0]
                                next unless GameObj.inv.find{|x| x.id == sack.id}
                                where = "##{sack.id}"
                                if what[0] == '#' and ix == 0
                                    fput "_drag #{what} #{where}"
                                else
                                    fput "get #{what}" if ix == 0
                                    fput "put #{what} in #{where}"
                                end
                                nil until get =~ /^Your .* won't fit in .*|<(left|right)>Empty</
                                waitfor '<prompt'
                                if $1
                                    success = true
                                    break
                                end
                                lootsacks << lootsacks.shift
                                # echo lootsacks.map{|x| x.name}.join('; ')
                            }
                            next if success
                            echo "All lootsacks are full, pausing script."
                            echo "#{$lich_char}unpause #{@script.name} to continue anyways, or abort with #{$lich_char}kill #{@script.name}"
                            pause_script
                        elsif command =~ /^echo (.*)$/i
                            before_next.call if before_next
                            before_next = nil
                            echo $1
                        elsif command =~ /^waitrt$/i
                            before_next = nil
                            waitrt
                        elsif command =~ /^waitrt\?$/i
                            before_next = nil
                            waitrt?
                        elsif command =~ /^waitcastrt$/i
                            before_next = nil
                            waitcastrt
                        elsif command =~ /^waitcastrt\?$/i
                            before_next = nil
                            waitcastrt?
                        elsif command =~ /^waitfor (.*)$/i
                            script.want_downstream = true
                            script.want_downstream_xml = false
                            waitfor $1
                            before_next = proc { waitrt? }
                            script.want_downstream_xml = true
                            script.want_downstream = false
                        elsif command =~ /^waitre (.*)$/i
                            text = $1
                            flags = nil
                            if text =~ /\/(.+)\/(.*)$/
                                text = $1
                                flags = $2 unless $2 == ''
                            end
                            pattern = Regexp::new(text, flags)
                            nil until get =~ pattern
                            before_next = proc { waitrt? }
                        elsif command =~ /^pause$/i
                            percent = (100.0 * processed_items / total_items).to_i
                            msg = []
                            msg << '<output class="mono" />' if $stormfront
                            msg << "[#{@script.name}: Pausing at #{self.item_detail(item)},  (#{processed_items + 1} of #{total_items}, #{percent}% complete)."
                            msg << '<output class="" />' if $stormfront
                            puts msg.join("\n")
                            pause_script
                            before_next = proc { waitrt? }
                        elsif command =~ /^giveitem(?:\s+(?:to\s+)?(.+))?$/i
                            before_next.call if before_next
                            before_next = nil
                            unless $1
                                echo 'Give to whom?'
                                exit
                            end
                            fput "give ##{item.id} to #{$1}"
                            script.want_downstream = true
                            script.want_downstream_xml = false
                            waitfor /^#{$1} has accepted your offer/
                            script.want_downstream_xml = true
                            script.want_downstream = false
                        elsif command =~ /^return(?:\s+item)?$/i
                            before_next.call if before_next
                            before_next = nil
                            if container
                                fput "put #{ref} in ##{container}"
                            elsif target =~ /^worn$/i
                                fput "wear #{ref}"
                            else
                                fput "place #{ref}"
                            end
                            #     waitfor '<right>', '<left>'  # Wait for a hand change.
                            # end
                        elsif command =~ /^sleep (\d*\.?\d+)$/i
                            sleep $1.to_f
                        elsif command =~ /^unmark\s+(.*)/i
                            before_next.call if before_next
                            before_next = nil
                            fput "mark #{$1} remove"
                        else
                            before_next.call if before_next
                            before_next = proc { waitrt? }
                            fput command
                            before_next = proc { waitfor '<prompt'; waitrt? }
                        end
                    }
                    processed_items += 1
                }
            else
                msg = ['']
                header = "[#{container_names[container]}]: "
                if @stormfront
                    header = REXML::Text.new(header).to_s
                    msg << "<preset id=\"whisper\">#{header}</preset>"
                else
                    header = REXML::Text.new(header).to_s if @profanity
                    msg << monsterbold_start + header + monsterbold_end
                end
                items.each{|item|
                    msg << item_detail(item)
                }
                puts msg.join("\n")
            end
        }
        unless commands.length > 0
            puts "\nTotal items: #{total_items}"
        end
    end

    def self.item_detail(item)
        if @stormfront
            noun = REXML::Text.new(item.noun).to_s
            text = REXML::Text.new("#{item.full_name} (#{item.type})").to_s
            return "<a exist=\"#{item.id}\" noun=\"#{noun}\">##{item.id}</a> #{text}"
        else
            text = "##{item.id} #{item.full_name} (#{item.type})"
            return REXML::Text.new(text).to_s if @profanity
            return text
        end
    end
end

if defined?(GameObj.type_data)
    GameObj.load_data if GameObj.type_data.empty? or GameObj.type_data.nil?
    if GameObj.type_data.nil?
        wait_while { running?('updater') }
        wait_while { running?('repository') }
        start_script 'repository', [ 'download', 'gameobj-data.xml' ]
        wait_while { running?('repository') }
        wait_while { running?('updater') }
        start_script 'updater', [ 'add', 'gameobj-data.xml' ]
        wait_while { running?('updater') }
        GameObj.load_data
        exit if GameObj.type_data.nil?
    end
end


ForeachScript.run(script)